#+TITLE: a
#+LATEX_CLASS: mimosis
#+SETUPFILE: thesis.setup
#+INCLUDE: "frontispiece.org"

* Introduzione

* Fattorizzazione cartesiana
I poliedri chiusi convessi che saranno utilizzati potranno essere rappresentati
in due modi:

+ tramite un sistema finito di vincoli $\mathcal{C}$. I vincoli
  non sono altro che le equazioni e disequazioni che individuano rispettivamente
  i semispazi e gli iperpiani del poliedro \cite{becchi};
+ tramite un sistema finito di generatori $\mathcal{G}$. Questi
  permettono di costruire il luogo geometrico dei punti determinati da
  combinazioni di particolari elementi del poliedro stesso \cite{becchi}. I
  generatori possono essere formati da:
  + *punto*: ogni elementi del poliedro $\mathcal{P}$ è un suo punto. Un punto
    può anche essere un /vertice/ se non può essere espresso come combinazione
    convessa di altri punti in $\mathcal{P}$;
  + *raggio*: un raggio di un poliedro non vuoto $\mathcal{P}$ è un vettore
    $\bm{r} \in \mathbb{R}^n$ non nullo tale che per ogni $\bm{x} \in
    \mathcal{P}$ e per ogni $\mu \ge 0$ vale
    #+BEGIN_EXPORT latex
    \begin{align*}
    (\bm{x} + \mu \bm{r}) \in \mathcal{P}
    \end{align*}
    #+END_EXPORT
    se $\mathcal{P} = \emptyset$ allora non ha raggi.

    Un raggio quindi definisce una direzione dove il poliedro è illimitato.
  + *retta*: un vettore $\bm{l} \in \mathbb{R}^n$ è una retta di un poliedro non
    vuoto $\mathcal{P}$ se e solo se i vettori $\bm{l}$ e -$\bm{l}$ sono
    entrambi raggi del poliedro $\mathcal{P}$. Vale quindi che per ogni $\bm{x}
    \in \mathcal{P}, \mu \in \mathbb{R}$
    #+BEGIN_EXPORT latex
    \begin{align*}
    (\bm{x} + \mu\bm{l}) \in \mathcal{P}
    \end{align*}
    #+END_EXPORT
    Se $\mathcal{P} = \emptyset$ allora non ha rette.

    Quindi possiamo esprimere un generatore come $\mathcal{G} =
    (\mathit{L},\mathit{R},\mathit{P})$ dove $\mathit{L},\mathit{R},\mathit{P}$
    sono sottoinsiemi finiti di $\mathbb{R}^n$ di cardinalità $l,r$ e $p$
    rispettivamente, tali che $0 \notin \mathit{R}$ e $0 \notin \mathit{L}$, con
    #+BEGIN_EXPORT latex
    \begin{align*}
    \mathcal{P} = \text{gen}(\mathcal{G}) \stackrel{\text{def}}{=} \{\mathit{L}\bm{\lambda} + \mathit{R}\bm{\rho} + \mathit{P}\bm{\pi} \: | \:
    \bm{\lambda} \in \mathbb{R}^l, \bm{\rho} \in \mathbb{R}^r_+, \bm{\pi} \in \mathbb{R}^p_+, \sum\limits_{i=1}^p \pi_i = 1\}
    \end{align*}
    #+END_EXPORT

    I punti di un poliedro $\mathcal{P}$ sono quindi ottenibili come combinazioni
    convesse dei punti in $\mathit{P}$ e come somma di combinazioni non negative
    dei raggi in $\mathit{R}$ (e quindi combinazioni lineari delle rette in $\mathit{L}$).



La fattorizzazione cartesiana, quando applicata, permette di diminuire la complessità di esecuzione
delle operazioni sui poliedri convessi. L'idea è che i poliedri
utilizzati nell'analisi dei programmi non mettono in relazione tutte le
variabili del programma in un solo vincolo. Per esempio: un ipercubo \\
$H_n = \{0 \le x_i \le 1 \; | \; i = 1,...,n\}$
richiede $2^n$ generatori di $n$ dimensioni per essere rappresentato, tramite la decomposizione
invece ne sono necessari solo $2n$ di dimensione 1. La terminologia e gli esempi saranno
ispirati al lavoro svolto in \cite{fastpoly}.

** Blocchi e fattori
Qui e nei successivi paragrafi verrano considerati esclusivamente poliedri /non/
vuoti.

Sia $\mathcal{X} = \{x_1, x_2,..., x_n\}$ un insieme di $n$ variabili. Dato un poliedro, $\mathcal{X}$
può essere partizionato in un sottoinsieme $\mathcal{X}_k$ che chiamiamo /blocco/ tale
che i vincoli esistono solo tra variabili presenti nello stesso /blocco/.
Quindi, ogni variabile priva di vincoli risiede in un singoletto. Ci riferiamo a
questo insieme come $\pi = \pi_P = \{\mathcal{X}_1, \mathcal{X}_2,..., \mathcal{X}_t\}$.

#+BEGIN_EXPORT latex
\begin{exmp}
Consideriamo
\begin{align*}
  &\mathcal{X} = \{x_1, x_2, x_3\} ~{}e \\
  &P = \{x_1 + 2x_2 \le 3\}.
\end{align*}

In questo caso $\mathcal{X}$ viene partizionato in due blocchi: $\mathcal{X}_1 = \{x_1, x_2\}$ e
$\mathcal{X}_2 = \{x_3\}$.
\end{exmp}
#+END_EXPORT

Per ogni blocco, quindi, sarà presente un /fattore/ $P_k$ che sarà composto solo
dalle variabili presenti nel suo blocco. In qualsiasi momento il poliedro
originale può essere recuperato "concatenando" i fattori, che equivale ad
applicare l'unione dei sistemi di vincoli
$\mathcal{C}_{P_k}$ e una variante del prodotto cartesiano (in quanto viene
applicato solo ai punti e non alle linee o ai raggi) dei generatori $\mathcal{G}_{P_k}$.

#+BEGIN_EXPORT latex
\begin{exmp}
  Consideriamo un poliedro $\mathcal{P}$ con i seguenti vincoli e generatori:
  \begin{align*}
    &\mathcal{C} = \{-x_{1} \le -1, x_{1} \le 4, -x_{2} \le -2, x_{2} \le 4\} \\
    &\mathcal{G} = \{\mathit{L}, \mathit{R}, (1,2)^T, (1,4)^T, (4,2)^T, (4,4)^T\} \\
    &\text{Con } \mathit{L} \text{ insieme delle rette e } \mathit{R} \text{ insieme dei raggi.}
  \end{align*}

  Il poliedro non ha vincoli tra le variabili $x_1$ e $x_2$. Quindi, $\mathcal{X} = \{x_1,x_2\}$
  può essere partizionato nei blocchi: $\pi_P = \{\{x_1\}, \{x_2\}\}$ con i risultanti fattori
  $P_1 = (\mathcal{C}_{P_1}, \mathcal{G}_{P_1})$ e $P_2 = (\mathcal{C}_{P_2}, \mathcal{G}_{P_2})$ dove:
  \begin{align*}
      &\mathcal{C}_{P_{1}} = \{-x_{1} \le -1, x_{1} \le 4\}  &&\mathcal{C}_{P_{2}} = \{ -x_{2} \le -2, x_{2} \le 4\} \\
      &\mathcal{G}_{P_{1}} = \{\mathit{L}, \mathit{R}, (1,4)^T\} &&\mathcal{G}_{P_{2}} = \{\mathit{L}, \mathit{R}, (2,4)^T\}
  \end{align*}
  Il poliedro originale può essere ricavato da $P_{1}$ e $P_{2}$ come
  P = $P_{1} \bowtie P_{2} = (\mathcal{C}_{P_{1}} \cup \mathcal{C}_{P_{2}}, \mathcal{G}_{P_{1}} \times \mathcal{G}_{P_{2}})$
\end{exmp}
#+END_EXPORT

L'insieme $\mathcal{L}$ che consiste in tutte le partizioni possibili di $\mathcal{X}$
forma un /reticolo di partizioni/ $(\mathcal{L}, \sqsubseteq, \sqcup, \sqcap,
\bot, \top)$. Gli elementi $\pi$ del reticolo sono ordinati come segue: $\pi
\sqsubseteq \pi'$, se ogni blocco di $\pi$ è incluso in qualche blocco di
$\pi'$, si dice quindi che \pi è "più fine" di \pi^' o, equivalentemente che
\pi^' è più "grossolana" di \pi. Questo reticolo è dotato degli operatori di /least upper bound/
$(\sqcup)$ che permette di calcolare, dati due blocchi, la partizione più
raffinata e /greatest upper bound/ $(\sqcap)$ che permette di calcolarne quella
più grossolana. È da notare che nel reticolo della
partizione $\top = \{\mathcal{X}\}$ e $\bot = \{\{x_1\}, \{x_2\}, ..., \{x_n\}\}$.

** Partizione ammissibile
Una partizione \pi è /ammissibile/ per un poliedro P se non esistono
variabili $x_i$ e $x_j$ in diversi blocchi di $\pi$ relazionati da un vincolo di
P, ovvero $\pi \sqsupseteq \pi_P$. Le partizioni ammissibili sono un
sottoinsieme chiuso superiormente del reticolo, chiameremo questo sottoinsieme
$\mathcal{B}$. Se $\pi \in \mathcal{B}$ allora lo saranno anche tutte
le $\pi'$ tali che $\pi, \pi' \in \mathcal{L}$ e
$\pi \sqsubseteq \pi'$. Le partizioni ammissibili sono
dotate di elemento minimo ovvero la più fine partizione appartenente a
$\mathcal{B}$, partizione che verrà anche considerata come la migliore. Questa
partizione minima viene calcolata come spiegato nell'*esempio 2.1.1*.

Il nostro obiettivo è quello di cercare di utilizzare sempre la partizione
ammissibile minima.
** Operazioni
In questo paragrafo verrà spiegato l'effetto che alcune operazioni dei poliedri
generano sui fattori. Occorre premettere che in quasi tutte le operazioni
binarie, i poliedri hanno la stessa dimensione. Fa eccezione la concatenazione. Per descrivere
meglio queste operazioni, è necessario prima dare una specifica di alcune
funzioni utilizzate all'interno delle prime.
$\\$
$\\$
\-\hspace{0.1cm} *Convert Constraint.* Funzione che mappa le dimensioni di un vincolo o
generatore all'interno di un fattore. La PPLite utilizza dimensioni nel range
$[0, ..., n]$ per i poliedri. Tramite la fattorizzazione è quindi necessario
tradurre gli indici esterni a quelli interni dei vari blocchi.
$\\$
$\\$
\-\hspace{0.1cm} *Least Upper Bound.* Questa funzione estrae il /lub/ di due partizioni.
Dall'Algoritmo 1 si può notare come sia necessario generare l'insieme delle
unioni dei due blocchi $\pi_{\mathcal{P}}$ e $\pi_{\mathcal{Q}}$ in
$\pi$. Successivamente si uniscono tra loro tutti i blocchi di
$\pi$ che hanno un'intersezione non vuota, calcolando
successivamente la partizione corretta.
  #+BEGIN_EXPORT latex
  \begin{algorithm}[H]
    \caption{Least-Upper-Bound}\label{lub}
    \begin{algorithmic}[1]
      \Function{Least-Upper-Bound}{$\pi_{\mathcal{P}}, \pi_{\mathcal{Q}}$}
      \State $\pi := \emptyset$
      \For{\textbf{each} $\mathcal{X}_{\mathcal{P}i}$ \textbf{in} $\pi_{\mathcal{P}}$}
      \State$\mathcal{B}$:= $\emptyset$
      \For{\textbf{each} $\mathcal{X}_{\mathcal{Q}k}$ \textbf{in} $\pi_{\mathcal{Q}}$}
      \If{$\mathcal{X}_{\mathcal{P}i} \cap\mathcal{X}_{\mathcal{Q}k} \ne \emptyset$}
      \State$\mathcal{B}:=\mathcal{B} \cup\mathcal{X}_{\mathcal{Q}k}$
      \EndIf
      \EndFor
      \State $\pi$.add($\mathcal{B}$)
      \EndFor
      \While{$\exists$ $\pi_i, \pi_j \in \pi$, $i \ne j$ \textbf{t.c.} $\mathcal{X}_i \cap \mathcal{X}_j \ne \emptyset$}
      \State $\pi$ := $(\pi \setminus \{\pi_i, \pi_j\}) \cup \{\pi_i \cup \pi_j\}$
      \EndWhile
      \Return $\pi$
      \EndFunction
    \end{algorithmic}
  \end{algorithm}
  #+END_EXPORT
$\\$
$\\$
\-\hspace{0.1cm} *Merge.* Definito come $\uparrow$, quando si ha l'operazione
$\pi \uparrow \mathcal{A}$, dove $\pi$ è una partizione di un poliedro e
$\mathcal{A}$ è un sottoinsieme delle sue variabili (non per forza connesse da
vincoli), genera una partizione $\pi_{m}$ tale che:
+ $\exists$ $\mathcal{X}_i \in \pi_m : \mathcal{A} \subseteq \mathcal{X}_i$, $\pi \sqsubseteq \pi_{m}$
Viene quindi generata una nuova fattorizzazione unendo i blocchi del poliedro
che hanno variabili in comune con $\mathcal{A}$. Questa unione genera un blocco
unico $\mathcal{D}$, tale che $\mathcal{A} \subseteq \mathcal{B}$.

#+BEGIN_EXPORT latex
\begin{algorithm}[H]
\caption{Merge}\label{merge}
\begin{algorithmic}[1]
\Function{Merge}{$\pi, \mathcal{A}$}
\State$\pi_m := \emptyset$
\State$\mathcal{B} := \emptyset$
\For{\textbf{each} $\mathcal{X}_{i}$ \textbf{in} $\pi$}
\If{$\mathcal{X}_{i} \cap \mathcal{A} \ne \emptyset$}
\State$\mathcal{B} := \mathcal{B} \cup \mathcal{X}_{i}$
\Else
\State$\pi_m$.add$(\mathcal{X}_{i})$
\EndIf
\EndFor
\State$\pi_m$.add$(\mathcal{B})$
\State\textbf{return} $\pi_m$
\EndFunction
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

\-\hspace{0.1cm} *Refactor.* Questa operazione ha come argomenti un poliedro
fattorizzato e una fattorizzazione ammissibile $\pi$ per questo
poliedro. Non fa altro che convertire i fattori rispetto alla seconda
fattorizzazione. È importante notare che la partizione ammissibile non sarà più
fine di $\pi_{\mathcal{P}}$, visto che i blocchi non vengono divisi bensì solo
uniti.

La refactor è un'operazione necessaria in quanto, avendo due poliedri
$\mathcal{P}$ e $\mathcal{Q}$ definiti sullo stesso insieme di variabili $X =
\{x_1, x_2, ..., x_n\}$ e presi $\pi_{\mathcal{P}} =
\{X_{\mathcal{P}_1}, X_{\mathcal{P}_2}, ..., X_{\mathcal{P}_r}\}$,
$\pi_{\mathcal{Q}} = \{X_{\mathcal{Q}_1}, X_{\mathcal{Q}_2}, ...,
X_{\mathcal{Q}_s}\}$
partizioni corrette di $\mathcal{P}$ e $\mathcal{Q}$ in genere abbiamo che
$\pi_{\mathcal{P}} \ne \pi_{\mathcal{Q}}$. È necessario
che, come in molte operazioni comuni nell'analisi e manipolazione dei poliedri,
le dimensioni delle partizioni utilizzate siano uguali in quantità e valori. Se
si applica la fattorizzazione su poliedri aventi gli stessi blocchi non si fa
altro che calcolare il /lub/ ($\pi = \pi_{\mathcal{P}}
\; \sqcup \; \pi_{\mathcal{Q}}$).

#+BEGIN_EXPORT latex
\begin{algorithm}[H]
\caption{Refactor}\label{refactor}
\begin{algorithmic}[1]
\Function{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \pi$}
\State$\mathcal{O}, \pi_{\mathcal{O}} := \emptyset$
\For{\textbf{each} $i$ \textbf{in} $\{1,..., r\}$} \Comment{r = numero blocchi di $\pi_{\mathcal{P}}$}
\State$\mathcal{O}_{i}, \pi_{\mathcal{O}i} := \emptyset$
\For{\textbf{each} $j$ \textbf{in} $\{1,...,m\}$} \Comment{m = numero blocchi di $\pi$}
\If{$\pi_{\mathcal{P}i} \cap \pi_{i} \ne \emptyset$}
\State$\mathcal{O}_{i}$ := $\mathcal{O}_{j} \bowtie \mathcal{P}_{i}$
\State$\pi_{\mathcal{O}i}$ := $\pi_{\mathcal{O}i} \bowtie \pi_{\mathcal{P}i}$
\EndIf
\EndFor
\State$\mathcal{O}$.add$(\mathcal{O}_{i})$
\State$\pi_{\mathcal{O}}$.add$(\pi_{\mathcal{O}i})$
\EndFor
\State\Call{Remap-Dimensions}{$\mathcal{O}, \pi_{\mathcal{O}}, \pi$}
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

Come spiegato precedentemente, la refactor prende in input un poliedro
fattorizzato $\mathcal{P}$ e la sua partizione $\pi_{\mathcal{P}}$ per
rifattorizzarlo in base al terzo parametro $\pi$. Non fa altro che
unire i fattori che hanno intersezione dei relativi blocchi non vuota tra
$\pi_{\mathcal{P}}$ e $\pi$ e generare il blocco finale. È importante
ri-mappare le dimensioni dei fattori di output in base a quelle descritte nel
blocco di $\pi$.

*** Inclusion Test ($\sqsubseteq$)
Operazione necessaria per controllare se un poliedro è incluso in un altro,
disponendo di una doppia rappresentazione è possibile controllarlo se, dati due
poliedri $\mathcal{P}$ e $\mathcal{Q}$ tutti i generatori in
$\mathcal{G}_{\mathcal{P}}$ soddisfano tutti i vincoli in
$\mathcal{C}_{\mathcal{Q}}$.

Nel nostro caso e, come mostrato nell'Algoritmo 4, è stata implementata tramite
wrapper. In particolare vengono rifattorizzati i poliedri con il /lub/
$\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}$ e successivamente viene applicata
l'/inclusion/ in ordine su ogni coppia di fattori: il test avrà successo se
tutti i test ritornano /True/.

#+BEGIN_EXPORT latex
\begin{algorithm}[H]
\caption{Inclusion Test}\label{inclusion test}
\begin{algorithmic}[1]
\Function{Inclusion}{$\mathcal{P},\pi_{\mathcal{P}},\mathcal{Q},\pi_{\mathcal{Q}}$}
\State$\pi$ := \Call{Leas-Upper-Bound}{$\pi_{\mathcal{P}},\pi_{\mathcal{Q}}$}
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \pi$}
\State$\mathcal{Q}'$ := \Call{Refactor}{$\mathcal{Q}, \pi_{\mathcal{Q}}, \pi$}
\For{\textbf{each} $k$ \textbf{in} $\{1,...,r\}$} \Comment{r = numero di blocchi in $\pi$}
\If{$\mathcal{P}'_{k}$ non include $\mathcal{Q}'_{k}$ }
\State\Return\textit{False}
\EndIf
\EndFor
\State\Return\textit{True}
\EndFunction
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

*** Join ($\sqcup$)
Tramite la doppia reppresentazione, i generatori $\mathcal{G}_{\mathcal{O}}$
dove $\mathcal{O}$ è il risultato del /join/, sono semplicemente l'unione dei
generatori dei poliedri presi in input dalla funzione, ovvero
$\mathcal{G}_{\mathcal{O}}$ = $\mathcal{G}_{\mathcal{P}} \cup
\mathcal{G}_{\mathcal{Q}}$. I vincoli $\mathcal{C}_{\mathcal{O}}$ sono ottenuti
aggiungendo incrementalmente i generatori di $\mathcal{G}_{\mathcal{Q}}$ al
poliedro definito da $\mathcal{C}_{\mathcal{P}}$.

#+BEGIN_EXPORT latex
\begin{algorithm}[H]
\caption{Join}\label{join}
\begin{algorithmic}[1]
\Function{Join}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{O}, \pi_{\mathcal{O}}$}
\If{\Call{is\_empty}{$\mathcal{P}$}}
\State$\mathcal{O}, \pi_{\mathcal{O}}$ := $\mathcal{Q}, \pi_{\mathcal{Q}}$
\ElsIf{\Call{is\_empty}{$\mathcal{Q}$}}
\State$\mathcal{O}, \pi_{\mathcal{O}}$ := $\mathcal{P}, \pi_{\mathcal{P}}$
\Else
\State$\mathcal{O}, \pi_{\mathcal{O}}$ := \Call{Join-Poly}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{O}, \pi_{\mathcal{O}}$}
\EndIf
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

Avendo un sistema di poliedri fattorizzati, è necessario per prima cosa
rifattorizzare $\mathcal{P}$ e $\mathcal{Q}$ utilizzando il loro /lub/. Per ogni
coppia di fattori $(\mathcal{P}'_{i}, \mathcal{Q}'_{i})$ uguali, se ne aggiunge
uno con il rispettivo blocco $\pi_i$ al risultato. Se invece i due
fattori risultano diversi, ognuno viene unito a un fattore comune
$(\mathcal{P}'_{i}, \mathcal{Q}'_{i})$ e successivamente si calcola la /join/ di
questi due fattori e si inserisce insieme al rispettivo blocco nel poliedro di
output.

Un caso speciale è stato assegnato ai poliedri /vuoti/. Dati $\mathcal{P}$ come
poliedro /vuoto/ e $\mathcal{Q}$ un poliedro generico allora $\mathcal{Q} \cup
\mathcal{P}$ = $\mathcal{Q}$ e anche $\mathcal{P} \cup
\mathcal{Q}$ = $\mathcal{Q}$.

Se invece $\pi = \pi_{\mathcal{P}} \sqcup
\pi_{\mathcal{Q}}$ e $\mathcal{U} = \{\mathcal{X}_k \: | \: \mathcal{P}
= \mathcal{Q}, \mathcal{X}_k \in \pi \}$ allora la partizione
ammissibile, in questo caso, sarà uguale a:

#+BEGIN_EXPORT latex
\begin{align*}
\pi_{\mathcal{P} \sqcup \mathcal{Q}} = \mathcal{U} \cup \bigcup_{\mathcal{T} \in \pi \backslash \mathcal{U}} \mathcal{T}
\end{align*}
#+END_EXPORT

#+BEGIN_EXPORT latex
\begin{algorithm}[H]
\caption{Join-Poly}\label{join-poly}
\begin{algorithmic}[1]
\Function{Join-Poly}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{O}, \pi_{\mathcal{O}}$}
\State$\pi$ := $\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}$
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P, \pi_{\mathcal{P}}, \pi}$}
\State$\mathcal{Q}'$ := \Call{Refactor}{$\mathcal{Q, \pi_{\mathcal{Q}}, \pi}$}
\For{\textbf{each} $i$ \textbf{in} $\{0,...,|\mathcal{P}'|\}$}
\If{$\mathcal{P}'_i = \mathcal{Q}'_i$}
\State$\mathcal{O}$.add$(\mathcal{P}'_{i})$
\State$\pi_{\mathcal{O}}$.add$(\mathcal{X}'_{i})$
\Else
\State$\mathcal{X}_{\mathcal{T}}$ := $\mathcal{X}_{\mathcal{T}} \cup \pi_{i}$
\State$\mathcal{P}_{\mathcal{T}}$ := $\mathcal{P}_{\mathcal{T}} \bowtie \mathcal{P}'_{i}$
\State$\mathcal{Q}_{\mathcal{T}}$ := $\mathcal{Q}_{\mathcal{T}} \bowtie \mathcal{Q}'_{i}$
\EndIf
\EndFor
\State$\mathcal{P}_{\mathcal{T}}$ := $\mathcal{P}_{\mathcal{T}} \sqcap \mathcal{Q}_{\mathcal{T}}$
\State$\pi_{\mathcal{O}}$.add$(\mathcal{X}_{\mathcal{T}})$
\State$\mathcal{O}$.add$(\mathcal{P}_{\mathcal{T}})$
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

#+END_EXPORT

*** Meet ($\sqcap$)
Per la doppia rappresentazione, $\mathcal{P} \sqcap \mathcal{Q}$ genera un
poliedro i cui vincoli $\mathcal{C}_{\mathcal{P} \sqcap \mathcal{Q}}$ sono
risultati dall'unione di $\mathcal{C}_{\mathcal{P}}$ e
$\mathcal{C}_{\mathcal{Q}}$, mentre $\mathcal{G}_{\mathcal{P} \sqcap
\mathcal{Q}}$ si ottiene aggiungendo incrementalmente i vincoli di
$\mathcal{C}_{\mathcal{Q}}$ al poliedro $\mathcal{P}$. Se $\mathcal{P} \sqcap
\mathcal{Q}$ risulta non soddisfacibile allora $\mathcal{P} \sqcap \mathcal{Q} =
\bot$ e $\mathcal{G}_{\mathcal{P} \sqcap \mathcal{Q}} = \emptyset$.

Per quanto riguarda i poliedri fattorizzati è necessario generare
$\pi = \pi_{\mathcal{P}} \sqcap
\pi_{\mathcal{Q}}$ e rifattorizzare i due poliedri $\mathcal{P}$ e
$\mathcal{Q}$ tramite essa, generando quindi $\mathcal{P}'$ e $\mathcal{Q}'$.
Per tutte le $r$ coppie di fattori $\mathcal{P}'_i$ e $\mathcal{Q}'_i$, se
sono uguali aggiungo $\mathcal{P}'_i$ con il rispettivo blocco al poliedro di
output $\mathcal{O}$, altrimenti creo un fattore $\mathcal{F} = \mathcal{P}'_i
\sqcap \mathcal{Q}'_i$. Se $\mathcal{F}$ dovesse risultare vuoto, allora il
risultato dell'intera operazione di /meet/ sarebbe un poliedro $\bot$. Se al
contrario non fosse vuoto, aggiungo $\mathcal{F}$ a $\mathcal{O}$ per poi
riprender il ciclo fino all'esaurimento dei fattori e ritornando infine
$\mathcal{O}$ e il suo blocco (rappresentato dal /lub/ di $\pi_{\mathcal{P}}$ e
$\pi_{\mathcal{Q}}$) come risultato. $\pi_{\mathcal{P} \sqcap
\mathcal{Q}} = \pi_{\mathcal{P}} \sqcap \pi_{\mathcal{Q}}$ è una partizione
ammissibile se $\mathcal{P} \sqcap \mathcal{Q} \ne \bot$, altrimenti $\bot$ è
ammissibile.

#+BEGIN_EXPORT latex
\begin{algorithm}[H]
\caption{Meet}\label{meet}
\begin{algorithmic}[1]
\Function{Meet}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{Q}, \pi_{\mathcal{Q}}$}
\State$\pi$ := $\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}$
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \pi$}
\State$\mathcal{Q}'$ := \Call{Refactor}{$\mathcal{Q}, \pi_{\mathcal{Q}}, \pi$}
\State$\mathcal{O}$ := $\emptyset$
\For{\textbf{each} $i$ \textbf{in} $\{1,...,r\}$}\Comment{r = numero di blocchi in $\pi$}
\If{$\mathcal{P}'_i = \mathcal{Q}'_i$}
\State$\mathcal{O}$.add$(\mathcal{P}'_i)$
\Else
\State$\mathcal{F}$ := $\mathcal{P}'_{i} \bowtie \mathcal{Q}'_{i}$
\If{\Call{is\_empty}{$\mathcal{F}$}}
\State\Return$\bot, \bot$
\EndIf
\State$\mathcal{O}$.add$(\mathcal{F})$
\EndIf
\EndFor
\State$\pi_{\mathcal{O}}$ := $\pi$
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}
#+END_EXPORT


*** Conditional
Questa operazione viene utilizzata per aggiungere nuovi vincoli tra le variabili
di un poliedro. Tramite la doppia rappresentazione è possibile aggiungendo un
vincolo arbitrario $c$ all'insieme $\mathcal{C}_{\mathcal{P}}$. Se dopo
l'inserimento il sistema di vincoli risulta insoddisfacibile allora il poliedro
diventa vuoto. Il sistema di generatori è, come sempre, ricavato dall'aggiunta
incrementale del vincolo $c$ nel poliedro attraverso la conversione.

Utilizzando poliedri fattorizzati è necessare ricavare il blocco $\mathcal{B}$ che contiene le
variabili utilizzate nel vincolo, rifattorizzando $\mathcal{P}$ con
$\pi_{\mathcal{P}} \uparrow \mathcal{B}$ si genera $\mathcal{P}'$.
Successivamente bisogna prendere il fattore relativo contenente le variabili di
$\mathcal{B}$, convertire il vincolo con le dimensioni /interne/ del fattore e
aggiungerlo a quest'ultimo utilizzando un'operazione per normali poliedri. Si
controlla, infine, che il sistema di vincoli sia ancora soddisfacibile e, in
caso negativo i blocchi e i fattori in $\bot$ vengono modificati e il poliedro
si rende /vuoto/. È importante far notare che, dato $\mathcal{O}$ un poliedro
risultante dall'aggiunta di un vincolo, $\pi_{\mathcal{O}} = \pi_{\mathcal{P}}
\uparrow \mathcal{B}$ è ammissibile se $\mathcal{O} \ne \bot$, altrimenti
$\pi_{\mathcal{O}} = \bot$.

#+BEGIN_EXPORT latex
\begin{algorithm}[H]
\caption{Conditional}\label{conditional}
\begin{algorithmic}[1]
\Function{Conditional}{$con$}
\State$\mathcal{B}$ := \Call{extract\_block}{$\mathcal{P}$, $\pi_{\mathcal{P}}$, \textit{con}}
\State$\pi$ := $\pi_{\mathcal{P}} \uparrow \mathcal{B}$
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \pi$}
\For{\textbf{each} $i$ \textbf{in} $\{1,...,r\}$}\Comment{r = numero di blocchi in $\pi$}
\If{$\mathcal{B} \cap \pi_i \ne \emptyset$}
\State$con_{int}$ := \Call{convert\_con}{$\pi_i$, \textit{con}}
\State$\mathcal{F}$ := \Call{add\_con}{$\mathcal{P}'_i, con_{int}$}
\State$\mathcal{O}$.add$(\mathcal{F})$
\If{\Call{is\_empty}{$\mathcal{O_{i}}$}}
\State\Return$\bot, \bot$
\EndIf
\State$\mathcal{O}$.add$(\mathcal{P'_i})$
\EndIf
\EndFor
\State$\pi_{\mathcal{O}}$ := $\pi$
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

*** Assignment
Per quanto riguarda il dominio dei poliedri fattorizzati, l'operazione di
/assignment/ è molto simile alla /conditional/. Dopo aver estratto il blocco
$\mathcal{B}$ che indica le variabili utilizzate nell'espressione lineare, si
fattorizza il poliedro $\mathcal{P}$ con $\pi_{\mathcal{P}} =
\pi_{\mathcal{P}} \uparrow \mathcal{B}$ ottenendo $\mathcal{P}'$,
successivamente si prende il blocco con le variabili di $\mathcal{B}$ e si
applica al relativo fattore un /assignment/ come per i poliedri non
fattorizzati, rimappando correttamente le variabili esterne rispetto a quelle
interne al fattore. La partizione ammissibile per un poliedro risultante da
questa operazione è $\pi_{\mathcal{P}} \uparrow \mathcal{B}$.

#+BEGIN_EXPORT latex
\begin{algorithm}[H]
\caption{Assignment}\label{assignment}
\begin{algorithmic}[1]
\Function{Assignment}{$\mathcal{P}$, $\pi_{\mathcal{P}}, stmt$}
\State let $stmt = (x_{i} = ax + \epsilon) $
\State$\mathcal{B}$ := \Call{extract\_block}{$stmt$}
\State$\pi$ := $\pi_{\mathcal{P}} \uparrow \mathcal{B}$
\State$\mathcal{P}'$ := \Call{refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \pi$}
\For{\textbf{each} $i$ \textbf{in} $\{1,...,r\}$}\Comment{$r = |\mathcal{P}|$}
\If{$\pi_i \subseteq \mathcal{B}$}
\State$stmt_{int}$ := \Call{convert}{$\pi, stmt$}
\State$\mathcal{F}$ := \Call{assignment}{$\mathcal{P}'_i, stmt_{int}$}\Comment{Poliedri non fattorizzati}
\State $\mathcal{O}$.add$(\mathcal{F})$
\If{$\mathcal{P}'_i$ := $\emptyset$}
\State\Return$\bot,\bot$
\EndIf
\Else
\State $\mathcal{O}$.add$(\mathcal{P}'_i)$
\EndIf
\EndFor
\State\Return $\mathcal{O}, \pi$
\EndFunction
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

*** Widening ($\nabla$)
Per la doppia rappresentazione, l'operatore di /widening/ necessità come
parametri i generatori e i vincoli di $\mathcal{P}$ e i vincolo di
$\mathcal{Q}$. Il risultato dell'operazione $\mathcal{P} \nabla
\mathcal{Q}$ conterrà i vincoli $\mathcal{C}_{\mathcal{Q}}$ che sono presenti in
$\mathcal{C}_{\mathcal{P}}$ o che possono sostituirne un vincolo senza cambiare
$\mathcal{P}$.

Per implementarlo è necessario effettuare uan rifattorizzazione $\mathcal{P}'$
del primo argomento $\mathcal{P}$ con $\pi = \pi_{\mathcal{P}} \sqcup
\pi_{\mathcal{Q}}$, mentre non è necessario rifattorizzare il secondo argomento.
Successivamente, per ogni fattore $\mathcal{Q}_i$ del secondo argomento si
individua il fattore corrispondente $\mathcal{P}'_k$ in $\mathcal{P}'$ e si
procede a individuare l'insieme $\mathcal{C}_{\mathcal{O}_i}$ di vincoli di
$\mathcal{Q}_i$ che sono /stabili/ rispetto a $\mathcal{P}'_k$: questi vincoli
costituiscono il risultato del widening rispetto a quel fattore. È possibile,
come caso speciale, che se $\pi_{\mathcal{P}'_k} = \pi_{\mathcal{Q}_i}$, allora è
possibile applicare direttamente l'operatore di widening per poliedri non
fattorizzati.

#+BEGIN_EXPORT latex
\begin{algorithm}[H]
\caption{Meet}\label{meet}
\begin{algorithmic}[1]
\Function{Widenind}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{Q}, \pi_{\mathcal{Q}}$}
\State $\pi$ := $\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}$
\State $\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \pi$}
\State $\mathcal{O}$ := $\emptyset$
\For{\textbf{each} $i$ \textbf{in} $\{1,...,r\}$}\Comment{$q$ = numero di blocchi in $\pi_{\mathcal{Q}}$}
\State $\mathcal{C}_{\mathcal{O}_i}$ := $\emptyset$
\State $k$ := $j$, t.c. $\mathcal{X}_{\mathcal{Q}_i} \subseteq \mathcal{X}_j, \mathcal{X}_j \in \pi$
\If{$\pi_k = \pi_{\mathcal{Q}_i}$}
\State $\mathcal{Q}_i$ := \Call{Widening}{$\mathcal{P}'_k, \mathcal{Q}_i$}
\Else
\State $\mathcal{C}_{\mathcal{O}_i}$ := \Call{select\_stable\_con}{$\mathcal{C}_{\mathcal{Q}_i}, \mathcal{P}'_k$}
\State $\mathcal{Q}_i$ := \Call{new\_factor}{$\mathcal{C}_{\mathcal{O}_i}$}
\EndIf
\State $\mathcal{O}$.add$(\mathcal{O}_i)$
\EndFor
\State\Return $\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}
#+END_EXPORT



* Implementazione
Questo capitolo tratterà dell'implementazione effettiva dei poliedri
fattorizzati e di alcune loro operazioni. La struttura è stata basata su di un
/wrapper/ preesistente nella /PPlite/ mentre alcune delle implementazioni sono
state attuate effettuando un porting dalla libreria /PPL/. La maggior parte delle
operazioni sono state sviluppate come un wrapper per la /PPLite/, difatti le
operazioni sui singoli poliedri sono gestite da essa. Lo scopo principale è
quello di inserirsi all'interno dell'analisi statica e utilizzare i poliedri
fattorizzati se e quando vengono generati poliedri che implicano un alto
overhead per essere gestiti, in questo caso i suddetti poliedri vengono
fattorizzati in maniera tale da diminuire il carico computazionale.
L'implementazione è stata sviluppata interamente in /C++11/ con l'obiettivo di
utilizzare i metodi della /libreria standard/ così da incrementare la leggibilità
del codice. L'efficienza non è stata presa come obiettivo principale durante lo
sviluppo, dando importanza alla correttezza e alla leggibilità del codice.

** ~F_Poly~
La classe dove sono compresi gran parte dei metodi è ~F_Poly~. È stata
definita nel file ~F_Poly.hh~ dove sono presenti 92 metodi pubblici e 14 metodi
privati.

Per la costruzione/distruzione degli oggetti è stata seguita la
/Rule of Five/, quindi abbiamo:

+ un costruttore esplicito, un costruttore per copia, un costruttore per spostamento;
+ operazioni di assegnamento per copia e per spostamento;
+ un distruttore.

In particolare, ci si è assicurati che il costruttore e l'assegnamento per
spostamento, generati in automatico dal compilatore, fossero dichiarati ~noexcept~: questo è richiesto allo scopo di
evitare l'uso di copie costose quando si utilizzano alcuni contenitori e
algoritmi della /STL/.

Abbiamo anche:

+ un metodo ~check_inv()~ per controllare che l'invariante di classe non sia
  stata violata;
+ le operazioni principali descritte nella sezione 2.3;
+ funzioni di appoggio per gestire il poliedro.

Sono presenti delle stutture dati per la gestione dei fattori:

+ ~block~ di tipo ~Block~: un ~std::vector~ di ~dim_type~ che rappresenta un blocco $\mathcal{X}_i$ che
  contiene alcune dimensioni del poliedro;
+ ~blocks~ di tipo ~Blocks~: un ~std::vector~ di ~Block~, che esprime la partizione del poliedro;
+ ~factor~ di tipo ~Factor~: un fattore è un poliedro, difatti ~Factor~ è un alias per oggetti di tipo ~Poly~;
+ ~factors~ di tipo ~Factors~: un ~std::vector~ di ~Factor~, ognuno dei quali in
  corrispondenza posizionale con il corrispondente blocco in ~blocks~.

Sono inoltre presenti tre variabili:

+ ~dim_type dim~: indicante le dimensioni del poliedro;
+ ~Topol topol~: indicante la topologia del poliedro;
+ ~bool is_empty~: indicante se il poliedro è vuoto o no.

*** ~check_inv()~
Il metodo menzionato contiene tutti i controlli necessari per verificare che
l'invariante di classe non sia stata violata, e che quindi il poliedro su cui si
sta lavorando è ben formato. Le invarianti di classe che devono
essere rispettate sono le seguenti:

+ la dimensione del poliedro deve essere $\ge 0$
  #+BEGIN_SRC C++
if (dim < 0) {
  reason = "F_Poly broken: invalid space dimension";
  maybe_dump();
  return false;
}
  #+END_SRC
  ;
+ se il poliedro è vuoto, i fattori e i blocchi devono essere anch'essi vuoti
  #+BEGIN_SRC C++
if (is_empty()) {
  if (!(factors.empty() && blocks.empty())) {
    reason = "F_Poly broken: empty polyhedron has factors";
    maybe_dump();
    return false;
  }
  // No other check for an empty polyhedron.
  return true;
}
  #+END_SRC
  ;
+ il numero di blocchi deve essere uguale al numero di fattori
  #+BEGIN_SRC C++
if (factors.size() != blocks.size()) {
  reason = "F_Poly broken: #factors != #blocks";
  maybe_dump();
  return false;
}
  #+END_SRC
  ;
+ la cardinalità totale dei blocchi deve essere uguale a ~dim~
  #+BEGIN_SRC C++
dim_type dim_ = 0;
for (const auto& block : blocks)
  dim_ += block.size();
if (dim != dim_) {
  reason = "F_Poly broken: space dimension mismatch";
  maybe_dump();
  return false;
}
  #+END_SRC
  ;
+ la dimensione di un fattore deve essere uguale alla dimensione del blocco
  che lo rappresenta
  #+BEGIN_SRC C++
// Each factor space dim should match its block.
for (dim_type i = 0; i < num_rows(factors); ++i)
  if (factors[i].space_dim() != num_rows(blocks[i])) {
    reason = "F_Poly broken: factor vs block space dim mismatch";
    maybe_dump();
    return false;
  }
  #+END_SRC
  ;
+ nessun fattore deve essere vuoto
  #+BEGIN_SRC C++
if (std::any_of(factors.begin(), factors.end(),
                std::mem_fn(&Poly::is_empty))) {
  reason = "F_Poly broken: empty factor";
  maybe_dump();
  return false;
}
  #+END_SRC
  ;
+ ogni dimensione dello spazio deve apparire una e una volta soltanto nei
  blocchi e non devono esserci blocchi vuoti (ovvero, ~blocks~ codifica solo una
  partizione)
  #+BEGIN_SRC C++
std::vector<bool> dims(dim, false);
for (const auto& block : blocks) {
  if (block.size() == 0) {
    reason = "F_Poly broken: found empty block";
    maybe_dump();
    return false;
  }
  for (const auto d : block) {
    if (d < 0 || d >= dim) {
      reason = "F_Poly broken: block contains an illegal
                space dim";
      maybe_dump();
      return false;
    }
    if (dims[d]) {
      reason = "F_Poly broken: repeated space dim in blocks";
      maybe_dump();
      return false;
    }
    dims[d] = true;
  }
}
  #+END_SRC
  ;
+ ogni dimensione dello spazio deve essere presente in un blocco
  #+BEGIN_SRC C++
if (std::find(dims.begin(), dims.end(), false) != dims.end()) {
  reason = "F_Poly broken: a space dim is missing from blocks";
  maybe_dump();
  return false;
}
  #+END_SRC
  .

** Operazione di base
Nel seguito si descrivono le implementazioni delle operazioni di base.

È stata seguita una metodologia che è possibile suddividere in tre fasi:

1. inizialmente è stato effettuato un porting del codice dalla /PPL/ alla
   /PPLite/, con adattamento alle strutture dati di quest'ultima;
2. successivamente è stato attuato un adeguamento incrementale agli standard di
   naming e codifica usati nella PPLite;
3. infine si è rivisto il codice scritto e si ci è apprestati a semplificarlo
   tramite l'utilizzo più sistematico di algoritmi della libreria standard e
   funzioni di supporto della PPLite. Questo ha permesso di avere un codice più
   corto e più facile da leggere.

Diverse sono le funzioni più significative definite all'interno di ~F_Poly.hh~:

#+BEGIN_SRC C++
static Factors refactor(const Factors& f,
                        const Blocks& b1, const Blocks& b2);
static Blocks least_upper_bound(const Blocks& b1, const Blocks& b2);
static Blocks merge(const Blocks& b, const Block& added);
void join(const Factors& f, const Blocks& b);
void join(const F_Poly& f);
void affine_image(Var var, const Linear_Expr& expr,
                  const Integer& inhomo = Integer::zero(),
                  const Integer& den = Integer::one());


void affine_preimage(Var var, const Linear_Expr& expr,
                     const Integer& inhomo = Integer::zero(),
                     const Integer& den = Integer::one());
void add_con(const Con& c);
void add_gen(const Gen& c);
bool inclusion(const Factors& f, const Blocks& b) const;
#+END_SRC

*** ~refactor~
La semantica rimane invariata invariata rispetto a quanto descritto
nell'Algoritmo \ref{refactor}. Per la /join/ $(\bowtie)$ tra i fattori è stata
utilizzata la ~concatenate_assign()~ della PPlite, una funzione omonima, per
quanto riguarda il join dei blocchi, è stata implementata utilizzando
~std::insert~[fn:insert]. E importante notare che questa operazione sia
ammissibile in quanto non c'è alcuna possibilità di dimensioni doppie
all'interno dei blocchi interessati.

#+BEGIN_SRC C++
Blocks bs(bs2.size());
  Factors res(bs.size(), Factor(0, Spec_Elem::UNIVERSE));
  for (dim_type i = 0; i != num_rows(bs1); ++i)
    for (dim_type j = 0; j != num_rows(bs2); ++j) {
      if (detail::are_disjoint(bs1[i], bs2[j]))
        continue;
      res[j].concatenate_assign(fs[i]);
      concatenate_assign(bs[j], bs1[i]);
    }
#+END_SRC

Per rimappare le dimensioni in maniera corretta viene utilizzata la funzione
~map_space_dims()~, che prende come argomento un oggetto di tipo ~Dims~ che
viene riempito delle varie dimensioni dei blocchi che saranno rimappati in base
all'indice in cui si trovano.

#+BEGIN_SRC C++
// Remap those factors res[i] s.t. bs[i] != bs2[i]
  for (dim_type i = 0; i != num_rows(bs2); ++i) {
    const auto& b = bs[i];
    const auto& b2 = bs2[i];
    assert(b.size() == b2.size());
    if (b == b2)
      continue;
    Dims pf(b.size());
    for (auto j = b.size(); j-- > 0; )
      pf[b[j]] = b2[j];
    res[i].map_space_dims(pf);
  }
  return res;
#+END_SRC

Il metodo ~are_disjoint(const Block& b1, const Block& b2)~ viene utilizzato per
vedere se due blocchi sono uguali.

#+BEGIN_SRC C++
inline bool
are_disjoint(const Block& b1, const Block& b2) {
  return std::find_first_of(b1.begin(), b1.end(),
                            b2.begin(), b2.end()) == b1.end();
}
#+END_SRC

Utilizza ~std::find_first_of~[fn:findfirstof] e ritorna falso se trova un elemento che è
presente in un insieme e non in un altro.

*** ~least_upper_bound~
L'implementazione di questo metodo non è stata menzionata in \cite{fastpoly} ma
ne è stato solo descritto l'aspetto matematico. In termini più pratici questa
operazione prende due parametri ~const Blocks& b1, const Blocks& b2~ e,
inizialmente, crea un blocco ~lub~ che sarà composto dalle dimensioni non in
comune tra ~b1~ e ~b2~:

#+BEGIN_SRC C++
Blocks lub; dim_type i = 0;
bool first = true;

for (const auto &bl1 : b1)
  for (const auto &bl2 : b2)
    if (!detail::are_disjoint(bl1, bl2)) {
      if (first) {
        lub.push_back(bl2);
        first = false;
      }
      else {
        lub[i] = block_union(lub[i], bl2);
      }
  ++i;
  first = true;
}
#+END_SRC

Successivamente si itera su ~lub~ per unire i blocchi che presentavano
dimensioni comuni fino a costruire la partizione ~lub~.

#+BEGIN_SRC C++
for (auto it1 = lub.begin(); it1 != lub.end(); ++it1)
  for (auto it2 = it1 + 1; it2 != lub.end(); ++it2)
    if (!detail::are_disjoint(*it1, *it2)) {
      ,*it1 = block_union(*it1, *it2);
      lub.erase(it2);
      --it2;
    }
#+END_SRC

Per unire i blocchi è stata utilizzata al funzione ~block_union(const Block& b1,
const Block& b2)~ che permette di unire i blocchi ed evitare che si vengano a
creare dimensioni doppie.

#+BEGIN_SRC C++
F_Poly::Block
F_Poly::block_union(const Block& b1, const Block& b2) {
  Block out(b1);
  bool add = true;
  for (const auto dim2 : b2) {
    for (const auto dim1 : b1)
      if (dim1 == dim2) {
        add = false;
        break;
      }
    if (add)
      out.push_back(dim2);
    else
      add = true;
  }
  return out;
}
#+END_SRC

*** ~add_con~
Il metodo ~add_con~ non è altro che l'implementazione dell'Algoritmo
\ref{conditional}. Per poter sviluppare questa operazione sono necessare due diverse
funzioni helper oltre a ~refactor~ e ~merge~:

+ ~extract_block()~: una funzione che, preso un vincolo, restituisce il blocco
  contenente tutte le variabili utilizzate in esso:
  #+BEGIN_SRC C++
inline Block
extract_block(const Linear_Expr& e) {
  Block var_block;
  for (dim_type i = 0; i != e.space_dim(); ++i)
    if (e.get(Var(i)) != 0)
      var_block.push_back(i);
  return var_block;
}
  #+END_SRC
  non facciamo altro che iterare una ~Linear_Expr~ inserendo tutte le variabili
  presenti in quest'ultima in un ~std::vector~.
+ ~convert~: è una funzione che permette di mappare le dimensioni di un vincolo.
  Definendo come /esterne/ le dimensioni del poliedro nella sua interezza e
  /interne/ quelle di un suo fattore, questo metodo effettua la traduzione da
  vincolo esterno a vincolo interno in base al blocco che viene passato.

*** ~affine_image~ e ~affine_preimage~
Questa funzione è l'implementazione dell'operazione /assignment/ vista
nell'Algoritmo \ref{assignment}. A differenza di quest'ultimo, per rimanere
coerenti con le definizioni della PPLite, la funzione prende in input:

+ Una variabile ~var~ di tipo ~Var~;
+ Un'espressione lineare ~expr~ di tipo ~Linear_Expr~;
+ Un intero ~inhomo~ di tipo ~Integer~ che rappresenta l'/inhomogeneus term/;
+ Un intero ~den~ di tipo ~Integer~ che rappresenta il /denominatore/.

Questi parametri formeranno lo statement $var = \frac{expr}{den} + inhomo$
equivalente a $x_i = ax + \epsilon$ dell'Algoritmo \ref{assignment}. Le uniche
differenze con lo pseudocodice sono che è necessario convertire sia ~var~ che
~expr~ in base al blocco corrispondente. Una volta convertite non si fa altro
che chiamare la ~affine_image~ della PPLite per ogni fattore.


#+BEGIN_SRC C++
void
F_Poly::affine_image(Var var, const Linear_Expr& expr,
                     const Integer& inhomo, const Integer& den) {
  Block b = detail::extract_block(expr);
  detail::add_var(b, var);
  Blocks bs_out = merge(blocks, b);
  factors = refactor(factors, blocks, bs_out);
  blocks = bs_out;
  for (dim_type i = 0; i < num_rows(factors); ++i) {
    if (detail::are_disjoint(b, blocks[i]))
      break;
    Var v_int = detail::convert(var, blocks[i]);
    Linear_Expr le_int = detail::convert(expr, blocks[i]);
    factors[i].affine_image(v_int, le_int, inhomo, den);
    if (factors[i].is_empty())
      set_empty();
  }
}
#+END_SRC

La funzione ~affine_preimage~ è identica a quella appena descritta, con l'unica
differenza di chiamare la ~affine_preimage~ della PPLite per ogni fattore.

** Altre operazioni
Oltre alle operazioni descritte in \cite{fastpoly} ne sono state aggiunte altre
per rendere più completa la classe. Tutte le operazioni descritte
successivamente non sono altro che il corrispettivo sui poliedri fattorizzati di
metodi omonimi presenti nella PPLite.

*** ~add_space_dims~ e ~remove_space_dims~
Funzioni che permettono l'aggiunta e la rimozione di dimensioni del poliedro, ne
sono state implementate tre versioni:

+ ~add_space_dims~: permette di aggiungere $n$ (con $n$ parametro della
  funzione) dimensioni al poliedro.
  Quest'ultimo viene incorporato nel nuovo spazio vettoriale. Avendo dei fattori
  implica che per ogni dimensione aggiunta deve essere aggiunto un nuovo blocco
  singoletto contenente la nuova dimensione e un rispettivo fattore /universo/
  di dimensione $1$. È presente anche un parametro ~bool project~ (settato a
  ~false~ di default) che permette, se passato come ~true~, di non incorporare il
  poliedro nel nuovo spazio vettoriale. Difatti, per ogni dimensione aggiunta
  viene creato un blocco singoletto che contiene la dimensione ~dim~ del
  poliedro, mentre il fattore viene creato da un sistema di vincoli che indica
  che la sua unica dimensione è vincolata ad assumere il valore 0:
  #+BEGIN_SRC C++
void
F_Poly::add_space_dims(dim_type m, bool project) {
  assert(m >= 0);
  if (m == 0)
    return;
  if (is_empty()) {
    dim += m;
    return;
  }
  Factor f(1, Spec_Elem::UNIVERSE, topology());
  if (project)
    f.add_con(Var(0) == 0);
  factors.insert(factors.end(), m, f);
  for (dim_type i = 0; i != m; ++i) {
    blocks.emplace_back(1, dim);
    ++dim;
  }
}
  #+END_SRC
+ ~remove_space_dim~: permette di rimuovere una dimensione dal poliedro. Il
  problema principale è che, rimuovendo una dimensione, è necessario
  riorganizzare i blocchi in modo tale da essere uniformati all'insieme
  $\{1,...,dim\}$. Questa operazione è riservata a una funzione chiamata
  ~reduce_blocks~:
  #+BEGIN_SRC C++
void
F_Poly::remove_space_dim(const dim_type v) {
  for (dim_type i = 0; i < num_rows(blocks); ++i)
    for (dim_type j = 0; j < num_rows(blocks[i]); ++j)
      if (v == blocks[i][j]) {
        if (num_rows(blocks[i]) == 1) {
          blocks.erase(blocks.begin() + i);
          factors.erase(factors.begin() + i);
          reduce_blocks(blocks, v);
        }
        else {
          blocks[i].erase(blocks[i].begin() + j);
          factors[i].remove_space_dim(Var(v));
          reduce_blocks(blocks, v);
        }
        --dim;
        return;
      }
}
  #+END_SRC
  È presente anche la versione ~remove_space_dims(const Index_Set& vars)~ che
  permette di rimuovere tutte le dimensioni presenti dentro ~vars~.
+ ~remove_higher_space_dims~: la sua implementazione utilizza la funzione
  precedente e non fa altro che rimuovere le $n$ dimensioni (con $n$ parametro
  della funzione) più grandi del poliedro:
    #+BEGIN_SRC C++
void
F_Poly::remove_higher_space_dims(dim_type new_dim) {
  if (is_empty()) {
    dim = new_dim;
    return;
  }
  for (dim_type i = space_dim(); i-- > new_dim; )
    remove_space_dim(i);
}
  #+END_SRC

*** ~add_con~ e ~add_gen~
Le due funzioni vengono utilizzate rispettivamente per aggiungere un vincolo e
un generatore al poliedro. Per quanto riguarda la prima, non è altro che la
/conditional/ vista nell'Algoritmo \ref{conditional}, la seconda è un caso a
parte.

Per ogni generatore che viene passato come parametro possono esserci tre casi:

+ *Il poliedro è vuoto*: in questo caso si controlla che il generatore sia un
  punto, successivamente tutto il poliedro viene settato come /universo/ e, per
  ogni fattore, viene aggiunto un vincolo $d \cdot 0 = coeff(Var(i))$
  #+BEGIN_SRC C++
if (is_empty()) {
  assert(g.is_point());
  *this = F_Poly(dim, Spec_Elem::UNIVERSE, topology());
  for (dim_type i = dim; i-- > 0; )
    factors[i].add_con(g.divisor() * Var(0) == g.coeff(Var(i)));
  assert(check_inv());
  return;
}
  #+END_SRC
+ *Il poliedro non è vuoto e il generatore è un punto*: in questo caso non si fa
  altro che costruire un insieme di fattori, ognuno dei quali conterrà il
  generatore passato come parametro; infine questi fattori vengono aggiunti al
  poliedro tramite la /join/:
  #+BEGIN_SRC C++
if (g.is_point()) {
  Factors fs_g;
  const auto nb = num_rows(blocks);
  fs_g.reserve(nb);
  for (dim_type i = 0; i != nb; ++i) {
    const auto& bi = blocks[i];
    const auto nbi = num_rows(bi);
    fs_g.emplace_back(nbi, Spec_Elem::UNIVERSE, topology());
    auto& fi = fs_g.back();
    for (dim_type j = 0; j != nbi; ++j)
      fi.add_con(g.divisor() * Var(j) == g.coeff(Var(bi[j])));
  }
  join(fs_g, blocks);
  assert(check_inv());
  return;
}
  #+END_SRC
+ *Il poliedro non è vuoto e il generatore non è un punto*: in questo caso viene
  creato un blocco $\mathcal{B}$ contentente tutte le dimensioni che appaiono
  nel generatore, successivamente si crea un blocco $\pi =
  \pi_{\mathcal{P}} \uparrow \mathcal{B}$ tramite il quale si ri-fattorizza il
  nostro poliedro in $\mathcal{P}'$. Infine, per ogni blocco che compare anche
  nel generatore si richiama la ~add_gen()~ della PPLite
  #+BEGIN_SRC C++
  assert(!is_empty() && !g.is_point());
  Block b_g = detail::extract_block(g);
  Blocks b_out = merge(blocks, b_g);
  factors = refactor(factors, blocks, b_out);
  blocks = b_out;

  for (dim_type i = 0; i != num_rows(blocks); ++i) {
    if (detail::are_disjoint(b_g, blocks[i]))
      continue;
    auto g_int = detail::convert(g, blocks[i]);
    factors[i].add_gen(std::move(g_int));
    break;
  }
  assert(check_inv());
  #+END_SRC

* Conclusione

#+LATEX: \bibliographystyle{plain}
#+LATEX: \renewcommand\bibname{Bibliografia}
#+LATEX: \bibliography{mybib}

* Footnotes

[fn:findfirstof] ~template <class InputIt, class ForwardIt>
InputIt find_first_of(InputIt first, InputIt last, ForwardIt s_first, ForwardIt s_last);~

[fn:vector] ~template<class T, class Allocator = std::allocator<T>> class vector;~

[fn:insert] ~template <class InputIt>
iterator insert(const_iterator pos, InputIt first, InputIt last);~

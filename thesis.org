#+TITLE: La fattorizzazione cartesiana nella libreria PPLite
#+AUTHOR: Luigi Zaccone

#+LATEX_CLASS: mimosis

#+SETUPFILE: thesis.setup


* Introduzione

* Fattorizzazione cartesiana
La fattorizzazione cartesiana permette di avere una complessità di esecuzione
minore sulle operazioni applicate ai poliedri. L'idea è che i poliedri
utilizzati nell'analisi dei programmi non mettono in relazione tutte le
variabili del programma in un solo vincolo. Per esempio: un ipercubo \\
$H_n = \{0 \le x_i \le 1 \; | \; i = 1,...,n\}$
richiede $2^n$ generatori per essere rappresentato, tramite la decomposizione
invece ne sono necessari solo $2n$.

** Blocchi e fattori
Sia $\mathcal{X} = \{x_1, x_2,..., x_n\}$ un insieme di $n$ variabili. Dato un poliedro, $\mathcal{X}$
può essere partizionato in un sottoinsieme $\mathcal{X}_k$ che chiamiamo /blocchi/ tale
che i vincoli esistono solo tra variabili presenti nello stesso /blocco/.
Quindi, ogni variabile priva di vincoli risiede in un singoletto. Ci riferiamo a
questo insieme come $\pi = \pi_P = \{\mathcal{X}_1, \mathcal{X}_2,..., \mathcal{X}_t\}$.

#+BEGIN_EXPORT latex
\begin{exmp}
Consideriamo
\begin{align*}
  &\mathcal{X} = \{x_1, x_2, x_3\} ~{}e \\
  &P = \{x_1 + 2x_2 \le 3\}.
\end{align*}

In questo caso $\mathcal{X}$ viene partizionato in due blocchi: $\mathcal{X}_1 = \{x_1, x_2\}$ e
$\mathcal{X}_2 = \{x_3\}$.
\end{exmp}
#+END_EXPORT

Per ogni blocco, quindi, sarà presente un /fattore/ $P_k$ che sarà composto solo
dalle variabili presenti nel suo blocco. In qualsiasi momento il poliedro
originale può essere recuperato applicando l'unione dei vincoli
$\mathcal{C}_{P_k}$ e il prodotto cartesiano dei generatori $\mathcal{G}_{P_k}$.

#+BEGIN_EXPORT latex
\begin{exmp}
  Consideriamo un poliedro $\mathcal{P}$ con i seguenti vincoli e generatori:
  \begin{align*}
    &\mathcal{C} = \{-x_{1} \le -1, x_{1} \le 4, -x_{2} \le -2, x_{2} \le 4\} \\
    &\mathcal{G} = \{\{(1),(2)\}, \{(1),(4)\}, \{(4),(2)\}, \{(4),(4)\}\}
  \end{align*}
  Il poliedro non ha vincoli tra le variabili $x_1$ e $x_2$. Quindi, $\mathcal{X} = \{x_1,x_2\}$
  può essere partizionato nei blocchi: $\pi_P = \{\{x_1\}, \{x_2\}\}$ con i risultanti fattori
  $P_1 = (\mathcal{C}_{P_1}, \mathcal{G}_{P_1})$ e $P_2 = (\mathcal{C}_{P_2}, \mathcal{G}_{P_2})$ dove:
  \begin{align*}
      &\mathcal{C}_{P_{1}} = \{-x_{1} \le -1, x_{1} \le 4\}  &&\mathcal{C}_{P_{2}} = \{ -x_{2} \le -2, x_{2} \le 4\} \\
      &\mathcal{G}_{P_{1}} = \{\{(1),(4)\}, \emptyset, \emptyset \} &&\mathcal{G}_{P_{2}} = \{\{(2),(4)\}, \emptyset, \emptyset \}
  \end{align*}
  Il poliedro originale può essere ricavato da $P_{1}$ e $P_{2}$ come
  P = $P_{1} \bowtie P_{2} = (\mathcal{C}_{P_{1}} \cup \mathcal{C}_{P_{2}}, \mathcal{G}_{P_{1}} \times \mathcal{G}_{P_{2}})$
\end{exmp}
#+END_EXPORT

L'insieme $\mathcal{L}$ che consiste in tutte le partizioni possibili di $\mathcal{X}$
forma un /reticolo di partizioni/ $(\mathcal{L}, \sqsubseteq, \sqcup, \sqcap,
\bot, \top)$. Gli elementi $\pi$ del reticolo sono ordinati come segue: $\pi
\sqsubseteq \pi'$, se ogni blocco di $\pi$ è incluso in qualche blocco di
$\pi'$. Questo reticolo contiene anche i soliti operatori di /least upper bound/
$(\sqcup)$ e /greatest upper bound/ $(\sqcap)$. È da notare che nel reticolo della
partizione $\top = \{\mathcal{X}\}$ e $\bot = \{\{x_1\}, \{x_2\}, ..., \{x_n\}\}$.

** Partizione ammissibile
Una partizione /ammissibile/ $\overline{\pi}$ è tale se, dato un poliedro P, non esistono
variabili $x_i$ e $x_j$ in diversi blocchi di $\pi$ relazionati da un vincolo di
P, ovvero $\pi \sqsupseteq \pi_P$. Le partizioni ammissibili sono un
sottoinsieme chiuso superiormente del reticolo, chiameremo questo sottoinsieme
$\mathcal{B}$. Se $\overline{\pi} \in \mathcal{B}$ allora lo saranno anche tutte
le $\overline{\pi}'$ tali che $\overline{\pi}, \overline{\pi}' \in \mathcal{L}$ e
$\overline{\pi} \sqsubseteq \overline{\pi}'$. Le partizioni ammissibili sono
dotate di elemento minimo ovvero la più fine partizione appartenente a
$\mathcal{B}$, partizione che verrà anche considerata come la migliore. Questa
partizione minima viene calcolata come spiegato nell'*esempio 2.1.1*.

Il nostro obiettivo è quello di cercare di utilizzare sempre la partizione
ammissibile minima.
** Operazioni
In questo paragrafo verrà spiegato l'effetto che alcune operazioni dei poliedri
generano sui fattori. Innanzitutto è fondamentalche che, nelle operazioni
binarie, i poliedri abbiano lo stesso numero di dimensioni. Per descrivere
meglio queste operazioni, è necessario prima dare una specifica di alcune
funzioni utilizzate all'interno delle prime.
$\\$
$\\$
\-\hspace{0.1cm} *Convert Constraint.* Funzione che mappa le dimensioni di un vincolo o
generatore all'interno di un fattore. La PPLite utilizza dimensioni nel range
$[0, ..., n]$ per i poliedri. Tramite la fattorizzazione è quindi necessario
tradurre gli indici esterni a quelli interni dei vari blocchi.
$\\$
$\\$
\-\hspace{0.1cm} *Least Upper Bound.* Questa funzione estrae il /lub/ di due partizioni.
Dall'Algoritmo 1 si può notare come sia necessario generare l'insieme delle
unioni dei due blocchi $\pi_{\mathcal{P}}$ e $\pi_{\mathcal{Q}}$ in
$\overline{\pi}$. Successivamente si uniscono tra loro tutti i blocchi di
$\overline{\pi}$ che hanno un'intersezione non vuota, calcolando
successivamente la partizione corretta.
  #+BEGIN_EXPORT latex
  \begin{algorithm}[H]
    \caption{Least-Upper-Bound}\label{lub}
    \begin{algorithmic}[1]
      \Function{Least-Upper-Bound}{$\pi_{\mathcal{P}}, \pi_{\mathcal{Q}}$}
      \State $\overline{\pi} := \emptyset$
      \For{\textbf{each} $\mathcal{X}_{\mathcal{P}i}$ \textbf{in} $\pi_{\mathcal{P}}$}
      \State$\mathcal{A}$:= $\emptyset$
      \For{\textbf{each} $\mathcal{X}_{\mathcal{Q}k} in \pi_{\mathcal{Q}}$}
      \If{$\mathcal{X}_{\mathcal{P}i} \cap\mathcal{X}_{\mathcal{Q}k} \ne \emptyset$}
      \State$\mathcal{A}:=\mathcal{B} \cup\mathcal{X}_{\mathcal{Q}k}$
      \EndIf
      \EndFor
      \State $\overline{\pi}$.add($\mathcal{A}$)
      \EndFor
      \While{$\exists$ coppie ($\overline{\pi}_i, \overline{\pi}_j$), $i \ne j$ \textbf{t.c.} $\overline{\pi}_i \cap \overline{\pi}_j \ne \emptyset$}
      \State $\overline{\pi}$ := $\ \{\overline{\pi}_i, \overline{\pi}_j\} \cup \{\overline{\pi}_i \cup \overline{\pi}_j\}\}$
      \EndWhile
      \Return $\overline{\pi}$
      \EndFunction
    \end{algorithmic}
  \end{algorithm}
  #+END_EXPORT
$\\$
$\\$
\-\hspace{0.1cm} *Merge.* Definito come $\uparrow$, quando si ha l'operazione
$\pi \uparrow \mathcal{A}$, dove $\pi$ è una partizione di un poliedro e
$\mathcal{A}$ è un sottoindieme delle sue variabili (non per forza connesse da
vincoli), genera una partizione $\pi_{merge}$ tale che:

+ $\exists$ $\mathcal{X}_i \in \pi_{merge} : \mathcal{A} \subseteq \mathcal{X}_i$
+ $\pi \sqsubseteq \pi_{merge}$

Viene quindi generata una nuova fattorizzazione unendo i blocchi del poliedro
che hanno variabili in comune con $\mathcal{A}$. Questa unione genera un blocco
unico $\mathcal{D}$, tale che $\mathcal{A} \subseteq \mathcal{B}$.

#+BEGIN_EXPORT latex
\begin{algorithm}[H]
\caption{Merge}\label{merge}
\begin{algorithmic}[1]
\Function{Merge}{$\pi, \mathcal{A}$}
\State$\pi_{\mathcal{O}} := \emptyset$
\State$\mathcal{D} := \emptyset$
\For{\textbf{each} $\mathcal{X}_{i}$ \textbf{in} $\pi$}
\If{$\mathcal{X}_{i} \cap \mathcal{A} \ne \emptyset$}
\State$\mathcal{D} := \mathcal{D} \cup \mathcal{X}_{i}$
\Else
\State$\pi_{\mathcal{O}}$.add$(\mathcal{X}_{i})$
\EndIf
\EndFor
\State$\pi_{\mathcal{O}}$.add$(\mathcal{D})$
\State\textbf{return} $\pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

\-\hspace{0.1cm} *Refactor.* Questa operazione ha come argomenti un poliedro
fattorizzato e una fattorizzazione ammissibile $\overline{\pi}$ per questo
poliedro. Non fa altro che convertire i fattori rispetto alla seconda
fattorizzazione. È importante notare che la partizione ammissibile non sarà più
fine di $\pi_{\mathcal{P}}$, visto che i blocchi non vengono divisi bensì solo
uniti.

La refactor è un'operazione necessaria in quanto, avendo due poliedri
$\mathcal{P}$ e $\mathcal{Q}$ definiti sullo stesso insieme di variabili $X =
\{x_1, x_2, ..., x_n\}$ e presi $\overline{\pi}_{\mathcal{P}} =
\{X_{\mathcal{P}_1}, X_{\mathcal{P}_2}, ..., X_{\mathcal{P}_r}\}$,
$\overline{\pi}_{\mathcal{Q}} = \{X_{\mathcal{Q}_1}, X_{\mathcal{Q}_2}, ...,
X_{\mathcal{Q}_s}\}$
partizioni corrette di $\mathcal{P}$ e $\mathcal{Q}$ in genere abbiamo che
$\overline{\pi}_{\mathcal{P}} \ne \overline{\pi}_{\mathcal{Q}}$. È necessario
che, come in molte operazioni comuni nell'analisi e manipolazione dei poliedri,
le dimensioni delle partizioni utilizzate siano uguali in quantità e valori. Se
si applica la fattorizzazione su poliedri aventi gli stessi blocchi non si fa
altro che calcolare il /lub/ ($\overline{\pi} = \overline{\pi}_{\mathcal{P}}
\; \sqcup \; \overline{\pi}_{\mathcal{Q}}$).

#+BEGIN_EXPORT latex
\begin{algorithm}[H]
\caption{Refactor}\label{refactor}
\begin{algorithmic}[1]
\Function{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \overline{\pi}$}
\State$\mathcal{O}, \pi_{\mathcal{O}} := \emptyset$
\For{\textbf{each} $i$ \textbf{in} $\{1,..., r\}$} \Comment{r = numero blocchi di $\pi_{\mathcal{P}}$}
\State$\mathcal{O}_{i}, \pi_{\mathcal{O}i} := \emptyset$
\For{\textbf{each} $j$ \textbf{in} $\{1,...,m\}$} \Comment{m = numero blocchi di $\overline{\pi}$}
\If{$\pi_{\mathcal{P}i} \cap \overline{\pi}_{i} \ne \emptyset$}
\State$\mathcal{O}_{i}$ := $\mathcal{O}_{j} \bowtie \mathcal{P}_{i}$
\State$\pi_{\mathcal{O}i}$ := $\pi_{\mathcal{O}i} \bowtie \pi_{\mathcal{P}i}$
\EndIf
\EndFor
\State$\mathcal{O}$.add$(\mathcal{O}_{i})$
\State$\pi_{\mathcal{O}}$.add$(\pi_{\mathcal{O}i})$
\EndFor
\State\Call{Remap-Dimensions}{$\mathcal{O}, \pi_{\mathcal{O}}, \overline{\pi}$}
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

Come spiegato precedentemente, la refactor prende in input un poliedro
fattorizzato $\mathcal{P}$ e la sua partizione $\pi_{\mathcal{P}}$ per
rifattorizzarlo in base al terzo parametro $\overline{\pi}$. Non fa altro che
unire i fattori che hanno intersezione dei relativi blocchi non vuota tra
$\pi_{\mathcal{P}}$ e $\overline{\pi}$ e generare il blocco finale. È importante
ri-mappare le dimensioni dei fattori di output in base a quelle descritte nel
blocco di $\overline{\pi}$.

*** Inclusion Test ($\sqsubseteq$)
Operazione necessaria per controllare se un poliedro è incluso in un altro,
disponendo di una doppia rappresentazione è possibile controllarlo se, dati due
poliedri $\mathcal{P}$ e $\mathcal{Q}$ tutti i generatori in
$\mathcal{G}_{\mathcal{P}}$ soddisfano tutti i vincoli in
$\mathcal{C}_{\mathcal{Q}}$.

Nel nostro caso e, come mostrato nell'Algoritmo 4, è stata implementata tramite
wrapper. In particolare vengono rifattorizzati i poliedri con il /lub/
$\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}$ e successivamente viene applicata
l'/inclusion/ in ordine su ogni coppia di fattori: il test avrà successo se
tutti i test ritornano /True/.

#+BEGIN_EXPORT latex
\begin{algorithm}[H]
\caption{Inclusion Test}\label{inclusion test}
\begin{algorithmic}[1]
\Function{Inclusion}{$\mathcal{P},\pi_{\mathcal{P}},\mathcal{Q},\pi_{\mathcal{Q}}$}
\State$\overline{\pi}$ := \Call{Leas-Upper-Bound}{$\pi_{\mathcal{P}},\pi_{\mathcal{Q}}$}
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \overline{\pi}$}
\State$\mathcal{Q}'$ := \Call{Refactor}{$\mathcal{Q}, \pi_{\mathcal{Q}}, \overline{\pi}$}
\For{\textbf{each} $k$ \textbf{in} $\{1,...,r\}$} \Comment{r = numero di blocchi in $\overline{\pi}$}
\If{$\mathcal{P}'_{k}$ non include $\mathcal{Q}'_{k}$ }
\State\Return\textit{False}
\EndIf
\EndFor
\State\Return\textit{True}
\EndFunction
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

*** Join ($\sqcup$)
Tramite la doppia reppresentazione, i generatori $\mathcal{G}_{\mathcal{O}}$
dove $\mathcal{O}$ è il risultato del /join/, sono semplicemente l'unione dei
generatori dei poliedri presi in input dalla funzione, ovvero
$\mathcal{G}_{\mathcal{O}}$ = $\mathcal{G}_{\mathcal{P}} \cup
\mathcal{G}_{\mathcal{Q}}$. I vincoli $\mathcal{C}_{\mathcal{O}}$ sono ottenuti
aggiungendo incrementalmente i generatori di $\mathcal{G}_{\mathcal{Q}}$ al
poliedro definito da $\mathcal{C}_{\mathcal{P}}$.

#+BEGIN_EXPORT latex
\begin{algorithm}[H]
\caption{Join}\label{join}
\begin{algorithmic}[1]
\Function{Join}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{O}, \pi_{\mathcal{O}}$}
\If{\Call{is\_empty}{$\mathcal{P}$}}
\State$\mathcal{O}, \pi_{\mathcal{O}}$ := $\mathcal{Q}, \pi_{\mathcal{Q}}$
\ElsIf{\Call{is\_empty}{$\mathcal{Q}$}}
\State$\mathcal{O}, \pi_{\mathcal{O}}$ := $\mathcal{P}, \pi_{\mathcal{P}}$
\Else
\State$\mathcal{O}, \pi_{\mathcal{O}}$ := \Call{Join-Poly}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{O}, \pi_{\mathcal{O}}$}
\EndIf
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

Avendo un sistema di poliedri fattorizzati, è necessario per prima cosa
rifattorizzare $\mathcal{P}$ e $\mathcal{Q}$ utilizzando il loro /lub/. Per ogni
coppia di fattori $(\mathcal{P}'_{i}, \mathcal{Q}'_{i})$ uguali, se ne aggiunge
uno con il rispettivo blocco $\overline{\pi}_i$ al risultato. Se invece i due
fattori risultano diversi, ognuno viene unito a un fattore comune
$(\mathcal{P}'_{i}, \mathcal{Q}'_{i})$ e successivamente si calcola la /join/ di
questi due fattori e si inserisce insieme al rispettivo blocco nel poliedro di
output.

Un caso speciale è stato assegnato ai poliedri /vuoti/. Dati $\mathcal{P}$ come
poliedro /vuoto/ e $\mathcal{Q}$ un poliedro generico allora $\mathcal{Q} \cup
\mathcal{P}$ = $\mathcal{Q}$ e anche $\mathcal{P} \cup
\mathcal{Q}$ = $\mathcal{Q}$.

Se invece $\overline{\pi} = \overline{\pi}_{\mathcal{P}} \sqcup
\overline{\pi}_{\mathcal{Q}}$ e $\mathcal{U} = \{\mathcal{X}_k \: | \: \mathcal{P}
= \mathcal{Q}, \mathcal{X}_k \in \overline{\pi} \}$ allora la partizione
ammissibile, in questo caso, sarà uguale a:

#+BEGIN_EXPORT latex
\begin{align*}
\overline{\pi}_{\mathcal{P} \sqcup \mathcal{Q}} = \mathcal{U} \cup \bigcup_{\mathcal{T} \in \overline{\pi} \backslash \mathcal{U}} \mathcal{T}
\end{align*}
#+END_EXPORT

#+BEGIN_EXPORT latex
\begin{algorithm}[H]
\caption{Join-Poly}\label{join-poly}
\begin{algorithmic}[1]
\Function{Join-Poly}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{O}, \pi_{\mathcal{O}}$}
\State$\overline{\pi}$ := $\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}$
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P, \pi_{\mathcal{P}}, \overline{\pi}}$}
\State$\mathcal{Q}'$ := \Call{Refactor}{$\mathcal{Q, \pi_{\mathcal{Q}}, \overline{\pi}}$}
\For{\textbf{each} $i$ \textbf{in} $\{0,...,|\mathcal{P}'|\}$}
\If{$\mathcal{P}'_i = \mathcal{Q}'_i$}
\State$\mathcal{O}$.add$(\mathcal{P}'_{i})$
\State$\pi_{\mathcal{O}}$.add$(\mathcal{X}'_{i})$
\Else
\State$\mathcal{X}_{\mathcal{T}}$ := $\mathcal{X}_{\mathcal{T}} \cup \overline{\pi}_{i}$
\State$\mathcal{P}_{\mathcal{T}}$ := $\mathcal{P}_{\mathcal{T}} \bowtie \mathcal{P}'_{i}$
\State$\mathcal{Q}_{\mathcal{T}}$ := $\mathcal{Q}_{\mathcal{T}} \bowtie \mathcal{Q}'_{i}$
\EndIf
\EndFor
\State$\mathcal{P}_{\mathcal{T}}$ := $\mathcal{P}_{\mathcal{T}} \sqcap \mathcal{Q}_{\mathcal{T}}$
\State$\pi_{\mathcal{O}}$.add$(\mathcal{X}_{\mathcal{T}})$
\State$\mathcal{O}$.add$(\mathcal{P}_{\mathcal{T}})$
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

#+END_EXPORT

*** Meet ($\sqcap$)
Per la doppia rappresentazione, $\mathcal{P} \sqcap \mathcal{Q}$ genera un
poliedro i cui vincoli $\mathcal{C}_{\mathcal{P} \sqcap \mathcal{Q}}$ sono
risultati dall'unione di $\mathcal{C}_{\mathcal{P}}$ e
$\mathcal{C}_{\mathcal{Q}}$, mentre $\mathcal{G}_{\mathcal{P} \sqcap
\mathcal{Q}}$ si ottiene aggiungendo incrementalmente i vincoli di
$\mathcal{C}_{\mathcal{Q}}$ al poliedro $\mathcal{P}$. Se $\mathcal{P} \sqcap
\mathcal{Q}$ risulta non soddisfacibile allora $\mathcal{P} \sqcap \mathcal{Q} =
\bot$ e $\mathcal{G}_{\mathcal{P} \sqcap \mathcal{Q}} = \emptyset$.

Per quanto riguarda i poliedri fattorizzati è necessario generare
$\overline{\pi} = \overline{\pi}_{\mathcal{P}} \sqcap
\overline{\pi}_{\mathcal{Q}}$ e rifattorizzare i due poliedri $\mathcal{P}$ e
$\mathcal{Q}$ tramite essa, generando quindi $\mathcal{P}'$ e $\mathcal{Q}'$.
Per tutte le $r$ coppie di fattori $\mathcal{P}'_i$ e $\mathcal{Q}'_i$, se
sono uguali aggiungo $\mathcal{P}'_i$ con il rispettivo blocco al poliedro di
output $\mathcal{O}$, altrimenti creo un fattore $\mathcal{F} = \mathcal{P}'_i
\sqcap \mathcal{Q}'_i$. Se $\mathcal{F}$ dovesse risultare vuoto, allora il
risultato dell'intera operazione di /meet/ sarebbe un poliedro $\bot$. Se al
contrario non fosse vuoto, aggiungo $\mathcal{F}$ a $\mathcal{O}$ per poi
riprender il ciclo fino all'esaurimento dei fattori e ritornando infine
$\mathcal{O}$ e il suo blocco (rappresentato dal /lub/ di $\pi_{\mathcal{P}}$ e
$\pi_{\mathcal{Q}}$) come risultato. $\overline{\pi}_{\mathcal{P} \sqcap
\mathcal{Q}} = \pi_{\mathcal{P}} \sqcap \pi_{\mathcal{Q}}$ è una partizione
ammissibile se $\mathcal{P} \sqcap \mathcal{Q} \ne \bot$, altrimenti $\bot$ è
ammissibile.

#+BEGIN_EXPORT latex
\begin{algorithm}[H]
\caption{Meet}\label{meet}
\begin{algorithmic}[1]
\Function{Meet}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{Q}, \pi_{\mathcal{Q}}$}
\State$\overline{\pi}$ := $\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}$
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \overline{\pi}$}
\State$\mathcal{Q}'$ := \Call{Refactor}{$\mathcal{Q}, \pi_{\mathcal{Q}}, \overline{\pi}$}
\State$\mathcal{O}$ := $\emptyset$
\For{\textbf{each} $i$ \textbf{in} $\{1,...,r\}$}\Comment{r = numero di blocchi in $\overline{\pi}$}
\If{$\mathcal{P}'_i = \mathcal{Q}'_i$}
\State$\mathcal{O}$.add$(\mathcal{P}'_i)$
\Else
\State$\mathcal{F}$ := $\mathcal{P}'_{i} \bowtie \mathcal{Q}'_{i}$
\If{\Call{is\_empty}{$\mathcal{F}$}}
\State\Return$\bot, \bot$
\EndIf
\State$\mathcal{O}$.add$(\mathcal{F})$
\EndIf
\EndFor
\State$\pi_{\mathcal{O}}$ := $\overline{\pi}$
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}
#+END_EXPORT


*** Conditional
Questa operazione viene utilizzata per aggiungere nuovi vincoli tra le variabili
di un poliedro. Tramite la doppia rappresentazione è possibile aggiungendo un
vincolo arbitrario $c$ all'insieme $\mathcal{C}_{\mathcal{P}}$. Se dopo
l'inserimento il sistema di vincoli risulta insoddisfacibile allora il poliedro
diventa vuoto. Il sistema di generatori è, come sempre, ricavato dall'aggiunta
incrementale del vincolo $c$ nel poliedro attraverso la conversione.

Utilizzando poliedri fattorizzati è necessare ricavare il blocco $\mathcal{B}$ che contiene le
variabili utilizzate nel vincolo, rifattorizzando $\mathcal{P}$ con
$\overline{\pi}_{\mathcal{P}} \uparrow \mathcal{B}$ si genera $\mathcal{P}'$.
Successivamente bisogna prendere il fattore relativo contenente le variabili di
$\mathcal{B}$, convertire il vincolo con le dimensioni /interne/ del fattore e
aggiungerlo a quest'ultimo utilizzando un'operazione per normali poliedri. Si
controlla, infine, che il sistema di vincoli sia ancora soddisfacibile e, in
caso negativo i blocchi e i fattori in $\bot$ vengono modificati e il poliedro
si rende /vuoto/. È importante far notare che, dato $\mathcal{O}$ un poliedro
risultante dall'aggiunta di un vincolo, $\overline{\pi}_{\mathcal{O}} = \overline{\pi}_{\mathcal{P}}
\uparrow \mathcal{B}$ è ammissibile se $\mathcal{O} \ne \bot$, altrimenti
$\overline{\pi}_{\mathcal{O}} = \bot$.

#+BEGIN_EXPORT latex
\begin{algorithm}[H]
\caption{Conditional}\label{conditional}
\begin{algorithmic}[1]
\Function{Conditional}{$con$}
\State$\mathcal{B}$ := \Call{extract\_block}{$\mathcal{P}$, $\pi_{\mathcal{P}}$, \textit{con}}
\State$\overline{\pi}$ := $\pi_{\mathcal{P}} \uparrow \mathcal{B}$
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \overline{\pi}$}
\For{\textbf{each} $i$ \textbf{in} $\{1,...,r\}$}\Comment{r = numero di blocchi in $\overline{\pi}$}
\If{$\mathcal{B} \cap \overline{\pi}_i \ne \emptyset$}
\State$con_{int}$ := \Call{convert\_con}{$\overline{\pi}_i$, \textit{con}}
\State$\mathcal{F}$ := \Call{add\_con}{$\mathcal{P}'_i, con_{int}$}
\State$\mathcal{O}$.add$(\mathcal{F})$
\If{\Call{is\_empty}{$\mathcal{O_{i}}$}}
\State\Return$\bot, \bot$
\EndIf
\State$\mathcal{O}$.add$(\mathcal{P'_i})$
\EndIf
\EndFor
\State$\pi_{\mathcal{O}}$ := $\overline{\pi}$
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

*** Assignment
Per quanto riguarda il dominio dei poliedri fattorizzati, l'operazione di
/assignment/ è molto simile alla /conditional/. Dopo aver estratto il blocco
$\mathcal{B}$ che indica le variabili utilizzate nell'espressione lineare, si
fattorizza il poliedro $\mathcal{P}$ con $\overline{\pi}_{\mathcal{P}} =
\pi_{\mathcal{P}} \uparrow \mathcal{B}$ ottenendo $\mathcal{P}'$,
successivamente si prende il blocco con le variabili di $\mathcal{B}$ e si
applica al relativo fattore un /assignment/ come per i poliedri non
fattorizzati, rimappando correttamente le variabili esterne rispetto a quelle
interne al fattore. La partizione ammissibile per un poliedro risultante da
questa operazione è $\overline{\pi}_{\mathcal{P}} \uparrow \mathcal{B}$.

#+BEGIN_EXPORT latex
\begin{algorithm}[H]
\caption{Assignment}\label{assignment}
\begin{algorithmic}[1]
\Function{Assignment}{$\mathcal{P}$, $\pi_{\mathcal{P}}, stmt$}
\State let $stmt = (x_{i} = ax + \epsilon) $
\State$\mathcal{B}$ := \Call{extract\_block}{$stmt$}
\State$\overline{\pi}$ := $\pi_{\mathcal{P}} \uparrow \mathcal{B}$
\State$\mathcal{P}'$ := \Call{refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \overline{\pi}$}
\For\textbf{each} $i$ \textbf{in} $\{1,...,r\}$\Comment{$r = |\mathcal{P}|$}
\If{$\overline{\pi}_i \subseteq \mathcal{B}$}
\State$stmt_{int}$ := \Call{convert}{$\overline{\pi}, stmt$}
\State$\mathcal{F}$ := \Call{assignment}{$\mathcal{P}'_i, stmt_{int}$}\Comment{Poliedri non fattorizzati}
\State $\mathcal{O}$.add$(\mathcal{F})$
\If{$\mathcal{P}'_i$ := $\emptyset$}
\State\Return$\bot,\bot$
\EndIf
\Else
\State $\mathcal{O}$.add$(\mathcal{P}'_i)$
\EndIf
\EndFor
\State\Return $\mathcal{O}, \overline{\pi}$
\EndFunction
\end{algorithmic}
\end{algorithm}
#+END_EXPORT

*** Widening ($\nabla$)
Per la doppia rappresentazione, l'operatore di /widening/ necessità come
parametri i generatori e i vincoli di $\mathcal{P}$ e i vincolo di
$\mathcal{Q}$. Il risultato dell'operazione $\mathcal{P} \nabla
\mathcal{Q}$ conterrà i vincoli $\mathcal{C}_{\mathcal{Q}}$ che sono presenti in
$\mathcal{C}_{\mathcal{P}}$ o che possono sostituirne un vincolo senza cambiare
$\mathcal{P}$.

Per implementarlo è necessario effettuare uan rifattorizzazione $\mathcal{P}'$
del primo argomento $\mathcal{P}$ con $\overline{\pi} = \pi_{\mathcal{P}} \sqcup
\pi_{\mathcal{Q}}$, mentre non è necessario rifattorizzare il secondo argomento.
Successivamente, per ogni fattore $\mathcal{Q}_i$ del secondo argomento si
individua il fattore corrispondente $\mathcal{P}'_k$ in $\mathcal{P}'$ e si
procede a individuare l'insieme $\mathcal{C}_{\mathcal{O}_i}$ di vincoli di
$\mathcal{Q}_i$ che sono /stabili/ rispetto a $\mathcal{P}'_k$: questi vincoli
costituiscono il risultato del widening rispetto a quel fattore. È possibile,
come caso speciale, che se $\pi_{\mathcal{P}'_k} = \pi_{\mathcal{Q}_i}$, allora è
possibile applicare direttamente l'operatore di widening per poliedri non fattorizzati.


* Implementazione
Qui andremo a parlare dell'implementazione concreta dei poliedri fattorizzati e
delle loro operazioni. In particolare, i metodi che modificano il poliedro
sono stati implementati utilizzando i già presenti, funzionanti e testati metodi
della /PPLite/. L'implementazione data è quindi da vedere come un *wrapper* di
quest'ultima.

** ~F_Poly~
La classe dove sono compresi gran parte dei medoti è ~F_Poly~. È stata
definita nel file ~F_Poly.hh~ dove sono presenti 92 metodi pubblici e 14 metodi
privati. I più significativi sono:

+ Un costruttore esplicito, un costruttore per copia, un costruttore per spostamento
+ Operazioni di assegnamento per copia e per spostamento
+ Un metodo ~check_inv()~ per controllare che le invarianti di classe non siano
  state violate
+ ??
+ Funzioni di appoggio per gestire il poliedro

Sono inoltre presenti delle stutture dati per la gestione dei fattori:

+ ~Block~: un ~std::vector~ di ~dim_type~ che rappresenta un blocco $X_i$ che
  contiene alcune dimensioni del poliedro
+ ~Blocks~: un ~std::vector~ di ~Block~ che esprimono le partizioni del poliedro
+ ~Factor~: un fattore è un poliedro, ~Factor~ è un alias per oggetti di tipo ~Poly~
+ ~Factors~: un ~std::vector~ di ~Factor~

Sono inoltre presenti tre variabili:

+ ~dim_type dim~: indicante le dimensioni del poliedro
+ ~Topol topol~: indicante la topologia del poliedro
+ ~bool is_empty~: indicante se il poliedro è o meno vuoto
*** ~check_inv()~
Il metodo menzionato contiene tutti i controlli necessari per verificare che
l'invariante di classe non sia stata violata, e che quindi il poliedro su cui si
sta lavorando è in condizioni di correttezza. Le invarianti di classe che devono
essere rispettate sono le seguenti:

+ La dimensione minima del poliedro deve essere $\ge 0$
  #+BEGIN_SRC C++
if (dim < 0) {
  reason = "F_Poly broken: invalid space dimension";
  maybe_dump();
  return false;
}
  #+END_SRC
+ Se il poliedro è vuoto, i fattori e i blocchi devono essere anch'essi vuoti
  #+BEGIN_SRC C++
if (is_empty()) {
  if (!(factors.empty() && blocks.empty())) {
    reason = "F_Poly broken: empty polyhedron has factors";
    maybe_dump();
    return false;
  }
  // No other check for an empty polyhedron.
  return true;
}
  #+END_SRC
+ Il numero di blocchi deve essere uguale al numero di fattori
  #+BEGIN_SRC C++
if (factors.size() != blocks.size()) {
  reason = "F_Poly broken: #factors != #blocks";
  maybe_dump();
  return false;
}
  #+END_SRC
+ La cardinalità dei blocchi deve essere uguale a ~dim~
  #+BEGIN_SRC C++
dim_type dim_ = 0;
for (const auto& block : blocks)
  dim_ += block.size();
if (dim != dim_) {
  reason = "F_Poly broken: space dimension mismatch";
  maybe_dump();
  return false;
}
  #+END_SRC
+ Le dimensioni di un fattore devono essere uguali alle dimensioni del blocco
  che lo rappresenta
  #+BEGIN_SRC C++
// Each factor space dim should match its block.
for (dim_type i = 0; i < num_rows(factors); ++i) {
  if (factors[i].space_dim() != num_rows(blocks[i])) {
    reason = "F_Poly broken: factor vs block space dim mismatch";
    maybe_dump();
    return false;
  }
}
  #+END_SRC
+ Nessun fattore deve essere vuoto
  #+BEGIN_SRC C++
if (std::any_of(factors.begin(), factors.end(),
                std::mem_fn(&Poly::is_empty))) {
  reason = "F_Poly broken: empty factor";
  maybe_dump();
  return false;
}
  #+END_SRC
+ Ogni dimensione dello spazio deve apparire una e una volta soltanto nei
  blocchi e non devono esserci blocchi vuoti
  #+BEGIN_SRC C++
std::vector<bool> dims(dim, false);
for (const auto& block : blocks) {
  if (block.size() == 0) {
    reason = "F_Poly broken: found empty block";
    maybe_dump();
    return false;
  }
  for (const auto d : block) {
    if (d < 0 || d >= dim) {
      reason = "F_Poly broken: block contains an illegal
                space dim";
      maybe_dump();
      return false;
    }
    if (dims[d]) {
      reason = "F_Poly broken: repeated space dim in blocks";
      maybe_dump();
      return false;
    }
    dims[d] = true;
  }
}
  #+END_SRC
+ Ogni dimensione dello spazio deve essere presente in un blocco
  #+BEGIN_SRC C++
if (std::find(dims.begin(), dims.end(), false) != dims.end()) {
  reason = "F_Poly broken: a space dim is missing from blocks";
  maybe_dump();
  return false;
}
  #+END_SRC

** Operazione di base
Le funzioni più significative di ~F_Poly~ sono state implementate più ad alto
livello, sfruttando le funzioni già implementate e funzionanti della /PPLite/.
Questo ha permesso di avere tempi di sviluppo più tempestivi e una fase di
testing meno problematica. Le funzioni principali, in parte discusse nel
capitolo uno, sono:

#+BEGIN_SRC C++
static Factors refactor(const Factors& f,
                        const Blocks& b1, const Blocks& b2);
static Blocks least_upper_bound(const Blocks& b1, const Blocks& b2);
static Blocks merge(const Blocks& b, const Block& added);
#+END_SRC

*** Refactoring


* Conclusione

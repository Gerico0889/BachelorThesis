% Created 2019-02-13 mer 16:29
% Intended LaTeX compiler: pdflatex
\documentclass{mimosis}
 \usepackage{minted}
 \addto\captionsenglish{\renewcommand\contentsname{Indice}}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{float}
\usepackage[noend]{algpseudocode}
\KOMAoptions{fontsize=12pt,headings=normal}
\makeglossaries
\theoremstyle{definition}
\newtheorem{exmp}{Esempio}[section]
\usepackage{amsmath}
\floatname{algorithm}{Algoritmo}

\newcommand{\mboxparagraph}[1]{\paragraph{#1}\mbox{}\\}
\newcommand{\mboxsubparagraph}[1]{\subparagraph{#1}\mbox{}\\}
\author{Luigi Zaccone}
\date{\today}
\title{La fattorizzazione cartesiana nella libreria PPLite}
\hypersetup{
 pdfauthor={Luigi Zaccone},
 pdftitle={La fattorizzazione cartesiana nella libreria PPLite},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.1 (Org mode 9.2)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents



\chapter{Introduzione}
\label{sec:orgf0c2b59}

\chapter{Fattorizzazione cartesiana}
\label{sec:org1fb8d64}
La fattorizzazione cartesiana permette di avere una complessità di esecuzione
minore sulle operazioni applicate ai poliedri. L'idea è che i poliedri
utilizzati nell'analisi dei programmi non mettono in relazione tutte le
variabili del programma in un solo vincolo. Per esempio: un ipercubo \\
\(H_n = \{0 \le x_i \le 1 \; | \; i = 1,...,n\}\)
richiede \(2^n\) generatori per essere rappresentato, tramite la decomposizione
invece ne sono necessari solo \(2n\).

\section{Blocchi e fattori}
\label{sec:org132ab6d}
Sia \(\mathcal{X} = \{x_1, x_2,..., x_n\}\) un insieme di \(n\) variabili. Dato un poliedro, \(\mathcal{X}\)
può essere partizionato in un sottoinsieme \(\mathcal{X}_k\) che chiamiamo \emph{blocchi} tale
che i vincoli esistono solo tra variabili presenti nello stesso \emph{blocco}.
Quindi, ogni variabile priva di vincoli risiede in un singoletto. Ci riferiamo a
questo insieme come \(\pi = \pi_P = \{\mathcal{X}_1, \mathcal{X}_2,..., \mathcal{X}_t\}\).

\begin{exmp}
Consideriamo
\begin{align*}
  &\mathcal{X} = \{x_1, x_2, x_3\} ~{}e \\
  &P = \{x_1 + 2x_2 \le 3\}.
\end{align*}

In questo caso $\mathcal{X}$ viene partizionato in due blocchi: $\mathcal{X}_1 = \{x_1, x_2\}$ e
$\mathcal{X}_2 = \{x_3\}$.
\end{exmp}

Per ogni blocco, quindi, sarà presente un \emph{fattore} \(P_k\) che sarà composto solo
dalle variabili presenti nel suo blocco. In qualsiasi momento il poliedro
originale può essere recuperato applicando l'unione dei vincoli
\(\mathcal{C}_{P_k}\) e il prodotto cartesiano dei generatori \(\mathcal{G}_{P_k}\).

\begin{exmp}
  Consideriamo un poliedro $\mathcal{P}$ con i seguenti vincoli e generatori:
  \begin{align*}
    &\mathcal{C} = \{-x_{1} \le -1, x_{1} \le 4, -x_{2} \le -2, x_{2} \le 4\} \\
    &\mathcal{G} = \{\{(1),(2)\}, \{(1),(4)\}, \{(4),(2)\}, \{(4),(4)\}\}
  \end{align*}
  Il poliedro non ha vincoli tra le variabili $x_1$ e $x_2$. Quindi, $\mathcal{X} = \{x_1,x_2\}$
  può essere partizionato nei blocchi: $\pi_P = \{\{x_1\}, \{x_2\}\}$ con i risultanti fattori
  $P_1 = (\mathcal{C}_{P_1}, \mathcal{G}_{P_1})$ e $P_2 = (\mathcal{C}_{P_2}, \mathcal{G}_{P_2})$ dove:
  \begin{align*}
      &\mathcal{C}_{P_{1}} = \{-x_{1} \le -1, x_{1} \le 4\}  &&\mathcal{C}_{P_{2}} = \{ -x_{2} \le -2, x_{2} \le 4\} \\
      &\mathcal{G}_{P_{1}} = \{\{(1),(4)\}, \emptyset, \emptyset \} &&\mathcal{G}_{P_{2}} = \{\{(2),(4)\}, \emptyset, \emptyset \}
  \end{align*}
  Il poliedro originale può essere ricavato da $P_{1}$ e $P_{2}$ come
  P = $P_{1} \bowtie P_{2} = (\mathcal{C}_{P_{1}} \cup \mathcal{C}_{P_{2}}, \mathcal{G}_{P_{1}} \times \mathcal{G}_{P_{2}})$
\end{exmp}

L'insieme \(\mathcal{L}\) che consiste in tutte le partizioni possibili di \(\mathcal{X}\)
forma un \emph{reticolo di partizioni} \((\mathcal{L}, \sqsubseteq, \sqcup, \sqcap,
\bot, \top)\). Gli elementi \(\pi\) del reticolo sono ordinati come segue: \(\pi
\sqsubseteq \pi'\), se ogni blocco di \(\pi\) è incluso in qualche blocco di
\(\pi'\). Questo reticolo contiene anche i soliti operatori di \emph{least upper bound}
\((\sqcup)\) e \emph{greatest upper bound} \((\sqcap)\). È da notare che nel reticolo della
partizione \(\top = \{\mathcal{X}\}\) e \(\bot = \{\{x_1\}, \{x_2\}, ..., \{x_n\}\}\).

\section{Partizione ammissibile}
\label{sec:orgbe46045}
Una partizione \emph{ammissibile} \(\overline{\pi}\) è tale se, dato un poliedro P, non esistono
variabili \(x_i\) e \(x_j\) in diversi blocchi di \(\pi\) relazionati da un vincolo di
P, ovvero \(\pi \sqsupseteq \pi_P\). Le partizioni ammissibili sono un
sottoinsieme chiuso superiormente del reticolo, chiameremo questo sottoinsieme
\(\mathcal{B}\). Se \(\overline{\pi} \in \mathcal{B}\) allora lo saranno anche tutte
le \(\overline{\pi}'\) tali che \(\overline{\pi}, \overline{\pi}' \in \mathcal{L}\) e
\(\overline{\pi} \sqsubseteq \overline{\pi}'\). Le partizioni ammissibili sono
dotate di elemento minimo ovvero la più fine partizione appartenente a
\(\mathcal{B}\), partizione che verrà anche considerata come la migliore. Questa
partizione minima viene calcolata come spiegato nell'\textbf{esempio 2.1.1}.

Il nostro obiettivo è quello di cercare di utilizzare sempre la partizione
ammissibile minima.
\section{Operazioni}
\label{sec:org31f32c0}
In questo paragrafo verrà spiegato l'effetto che alcune operazioni dei poliedri
generano sui fattori. Innanzitutto è fondamentalche che, nelle operazioni
binarie, i poliedri abbiano lo stesso numero di dimensioni. Per descrivere
meglio queste operazioni, è necessario prima dare una specifica di alcune
funzioni utilizzate all'interno delle prime.
\(\\\)
\(\\\)
\-\hspace{0.1cm} \textbf{Convert Constraint.} Funzione che mappa le dimensioni di un vincolo o
generatore all'interno di un fattore. La PPLite utilizza dimensioni nel range
\([0, ..., n]\) per i poliedri. Tramite la fattorizzazione è quindi necessario
tradurre gli indici esterni a quelli interni dei vari blocchi.
\(\\\)
\(\\\)
\-\hspace{0.1cm} \textbf{Least Upper Bound.} Questa funzione estrae il \emph{lub} di due partizioni.
Dall'Algoritmo 1 si può notare come sia necessario generare l'insieme delle
unioni dei due blocchi \(\pi_{\mathcal{P}}\) e \(\pi_{\mathcal{Q}}\) in
\(\overline{\pi}\). Successivamente si uniscono tra loro tutti i blocchi di
\(\overline{\pi}\) che hanno un'intersezione non vuota, calcolando
successivamente la partizione corretta.
\begin{algorithm}[H]
  \caption{Least-Upper-Bound}\label{lub}
  \begin{algorithmic}[1]
    \Function{Least-Upper-Bound}{$\pi_{\mathcal{P}}, \pi_{\mathcal{Q}}$}
    \State $\overline{\pi} := \emptyset$
    \For{\textbf{each} $\mathcal{X}_{\mathcal{P}i}$ \textbf{in} $\pi_{\mathcal{P}}$}
    \State$\mathcal{A}$:= $\emptyset$
    \For{\textbf{each} $\mathcal{X}_{\mathcal{Q}k} in \pi_{\mathcal{Q}}$}
    \If{$\mathcal{X}_{\mathcal{P}i} \cap\mathcal{X}_{\mathcal{Q}k} \ne \emptyset$}
    \State$\mathcal{A}:=\mathcal{B} \cup\mathcal{X}_{\mathcal{Q}k}$
    \EndIf
    \EndFor
    \State $\overline{\pi}$.add($\mathcal{A}$)
    \EndFor
    \While{$\exists$ coppie ($\overline{\pi}_i, \overline{\pi}_j$), $i \ne j$ \textbf{t.c.} $\overline{\pi}_i \cap \overline{\pi}_j \ne \emptyset$}
    \State $\overline{\pi}$ := $\ \{\overline{\pi}_i, \overline{\pi}_j\} \cup \{\overline{\pi}_i \cup \overline{\pi}_j\}\}$
    \EndWhile
    \Return $\overline{\pi}$
    \EndFunction
  \end{algorithmic}
\end{algorithm}
\(\\\)
\(\\\)
\-\hspace{0.1cm} \textbf{Merge.} Definito come \(\uparrow\), quando si ha l'operazione
\(\pi \uparrow \mathcal{A}\), dove \(\pi\) è una partizione di un poliedro e
\(\mathcal{A}\) è un sottoindieme delle sue variabili (non per forza connesse da
vincoli), genera una partizione \(\pi_{merge}\) tale che:

\begin{itemize}
\item \(\exists\) \(\mathcal{X}_i \in \pi_{merge} : \mathcal{A} \subseteq \mathcal{X}_i\)
\item \(\pi \sqsubseteq \pi_{merge}\)
\end{itemize}

Viene quindi generata una nuova fattorizzazione unendo i blocchi del poliedro
che hanno variabili in comune con \(\mathcal{A}\). Questa unione genera un blocco
unico \(\mathcal{D}\), tale che \(\mathcal{A} \subseteq \mathcal{B}\).

\begin{algorithm}[H]
\caption{Merge}\label{merge}
\begin{algorithmic}[1]
\Function{Merge}{$\pi, \mathcal{A}$}
\State$\pi_{\mathcal{O}} := \emptyset$
\State$\mathcal{D} := \emptyset$
\For{\textbf{each} $\mathcal{X}_{i}$ \textbf{in} $\pi$}
\If{$\mathcal{X}_{i} \cap \mathcal{A} \ne \emptyset$}
\State$\mathcal{D} := \mathcal{D} \cup \mathcal{X}_{i}$
\Else
\State$\pi_{\mathcal{O}}$.add$(\mathcal{X}_{i})$
\EndIf
\EndFor
\State$\pi_{\mathcal{O}}$.add$(\mathcal{D})$
\State\textbf{return} $\pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\-\hspace{0.1cm} \textbf{Refactor.} Questa operazione ha come argomenti un poliedro
fattorizzato e una fattorizzazione ammissibile \(\overline{\pi}\) per questo
poliedro. Non fa altro che convertire i fattori rispetto alla seconda
fattorizzazione. È importante notare che la partizione ammissibile non sarà più
fine di \(\pi_{\mathcal{P}}\), visto che i blocchi non vengono divisi bensì solo
uniti.

La refactor è un'operazione necessaria in quanto, avendo due poliedri
\(\mathcal{P}\) e \(\mathcal{Q}\) definiti sullo stesso insieme di variabili \(X =
\{x_1, x_2, ..., x_n\}\) e presi \(\overline{\pi}_{\mathcal{P}} =
\{X_{\mathcal{P}_1}, X_{\mathcal{P}_2}, ..., X_{\mathcal{P}_r}\}\),
\(\overline{\pi}_{\mathcal{Q}} = \{X_{\mathcal{Q}_1}, X_{\mathcal{Q}_2}, ...,
X_{\mathcal{Q}_s}\}\)
partizioni corrette di \(\mathcal{P}\) e \(\mathcal{Q}\) in genere abbiamo che
\(\overline{\pi}_{\mathcal{P}} \ne \overline{\pi}_{\mathcal{Q}}\). È necessario
che, come in molte operazioni comuni nell'analisi e manipolazione dei poliedri,
le dimensioni delle partizioni utilizzate siano uguali in quantità e valori. Se
si applica la fattorizzazione su poliedri aventi gli stessi blocchi non si fa
altro che calcolare il \emph{lub} (\(\overline{\pi} = \overline{\pi}_{\mathcal{P}}
\; \sqcup \; \overline{\pi}_{\mathcal{Q}}\)).

\begin{algorithm}[H]
\caption{Refactor}\label{refactor}
\begin{algorithmic}[1]
\Function{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \overline{\pi}$}
\State$\mathcal{O}, \pi_{\mathcal{O}} := \emptyset$
\For{\textbf{each} $i$ \textbf{in} $\{1,..., r\}$} \Comment{r = numero blocchi di $\pi_{\mathcal{P}}$}
\State$\mathcal{O}_{i}, \pi_{\mathcal{O}i} := \emptyset$
\For{\textbf{each} $j$ \textbf{in} $\{1,...,m\}$} \Comment{m = numero blocchi di $\overline{\pi}$}
\If{$\pi_{\mathcal{P}i} \cap \overline{\pi}_{i} \ne \emptyset$}
\State$\mathcal{O}_{i}$ := $\mathcal{O}_{j} \bowtie \mathcal{P}_{i}$
\State$\pi_{\mathcal{O}i}$ := $\pi_{\mathcal{O}i} \bowtie \pi_{\mathcal{P}i}$
\EndIf
\EndFor
\State$\mathcal{O}$.add$(\mathcal{O}_{i})$
\State$\pi_{\mathcal{O}}$.add$(\pi_{\mathcal{O}i})$
\EndFor
\State\Call{Remap-Dimensions}{$\mathcal{O}, \pi_{\mathcal{O}}, \overline{\pi}$}
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

Come spiegato precedentemente, la refactor prende in input un poliedro
fattorizzato \(\mathcal{P}\) e la sua partizione \(\pi_{\mathcal{P}}\) per
rifattorizzarlo in base al terzo parametro \(\overline{\pi}\). Non fa altro che
unire i fattori che hanno intersezione dei relativi blocchi non vuota tra
\(\pi_{\mathcal{P}}\) e \(\overline{\pi}\) e generare il blocco finale. È importante
ri-mappare le dimensioni dei fattori di output in base a quelle descritte nel
blocco di \(\overline{\pi}\).

\subsection{Inclusion Test (\(\sqsubseteq\))}
\label{sec:org6537ad5}
Operazione necessaria per controllare se un poliedro è incluso in un altro,
disponendo di una doppia rappresentazione è possibile controllarlo se, dati due
poliedri \(\mathcal{P}\) e \(\mathcal{Q}\) tutti i generatori in
\(\mathcal{G}_{\mathcal{P}}\) soddisfano tutti i vincoli in
\(\mathcal{C}_{\mathcal{Q}}\).

Nel nostro caso e, come mostrato nell'Algoritmo 4, è stata implementata tramite
wrapper. In particolare vengono rifattorizzati i poliedri con il \emph{lub}
\(\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}\) e successivamente viene applicata
l'\emph{inclusion} in ordine su ogni coppia di fattori: il test avrà successo se
tutti i test ritornano \emph{True}.

\begin{algorithm}[H]
\caption{Inclusion Test}\label{inclusion test}
\begin{algorithmic}[1]
\Function{Inclusion}{$\mathcal{P},\pi_{\mathcal{P}},\mathcal{Q},\pi_{\mathcal{Q}}$}
\State$\overline{\pi}$ := \Call{Leas-Upper-Bound}{$\pi_{\mathcal{P}},\pi_{\mathcal{Q}}$}
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \overline{\pi}$}
\State$\mathcal{Q}'$ := \Call{Refactor}{$\mathcal{Q}, \pi_{\mathcal{Q}}, \overline{\pi}$}
\For{\textbf{each} $k$ \textbf{in} $\{1,...,r\}$} \Comment{r = numero di blocchi in $\overline{\pi}$}
\If{$\mathcal{P}'_{k}$ non include $\mathcal{Q}'_{k}$ }
\State\Return\textit{False}
\EndIf
\EndFor
\State\Return\textit{True}
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Join (\(\sqcup\))}
\label{sec:orgfa1274c}
Tramite la doppia reppresentazione, i generatori \(\mathcal{G}_{\mathcal{O}}\)
dove \(\mathcal{O}\) è il risultato del \emph{join}, sono semplicemente l'unione dei
generatori dei poliedri presi in input dalla funzione, ovvero
\(\mathcal{G}_{\mathcal{O}}\) = \(\mathcal{G}_{\mathcal{P}} \cup
\mathcal{G}_{\mathcal{Q}}\). I vincoli \(\mathcal{C}_{\mathcal{O}}\) sono ottenuti
aggiungendo incrementalmente i generatori di \(\mathcal{G}_{\mathcal{Q}}\) al
poliedro definito da \(\mathcal{C}_{\mathcal{P}}\).

\begin{algorithm}[H]
\caption{Join}\label{join}
\begin{algorithmic}[1]
\Function{Join}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{O}, \pi_{\mathcal{O}}$}
\If{\Call{is\_empty}{$\mathcal{P}$}}
\State$\mathcal{O}, \pi_{\mathcal{O}}$ := $\mathcal{Q}, \pi_{\mathcal{Q}}$
\ElsIf{\Call{is\_empty}{$\mathcal{Q}$}}
\State$\mathcal{O}, \pi_{\mathcal{O}}$ := $\mathcal{P}, \pi_{\mathcal{P}}$
\Else
\State$\mathcal{O}, \pi_{\mathcal{O}}$ := \Call{Join-Poly}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{O}, \pi_{\mathcal{O}}$}
\EndIf
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

Avendo un sistema di poliedri fattorizzati, è necessario per prima cosa
rifattorizzare \(\mathcal{P}\) e \(\mathcal{Q}\) utilizzando il loro \emph{lub}. Per ogni
coppia di fattori \((\mathcal{P}'_{i}, \mathcal{Q}'_{i})\) uguali, se ne aggiunge
uno con il rispettivo blocco \(\overline{\pi}_i\) al risultato. Se invece i due
fattori risultano diversi, ognuno viene unito a un fattore comune
\((\mathcal{P}'_{i}, \mathcal{Q}'_{i})\) e successivamente si calcola la \emph{join} di
questi due fattori e si inserisce insieme al rispettivo blocco nel poliedro di
output.

Un caso speciale è stato assegnato ai poliedri \emph{vuoti}. Dati \(\mathcal{P}\) come
poliedro \emph{vuoto} e \(\mathcal{Q}\) un poliedro generico allora \(\mathcal{Q} \cup
\mathcal{P}\) = \(\mathcal{Q}\) e anche \(\mathcal{P} \cup
\mathcal{Q}\) = \(\mathcal{Q}\).

Se invece \(\overline{\pi} = \overline{\pi}_{\mathcal{P}} \sqcup
\overline{\pi}_{\mathcal{Q}}\) e \(\mathcal{U} = \{\mathcal{X}_k \: | \: \mathcal{P}
= \mathcal{Q}, \mathcal{X}_k \in \overline{\pi} \}\) allora la partizione
ammissibile, in questo caso, sarà uguale a:

\begin{align*}
\overline{\pi}_{\mathcal{P} \sqcup \mathcal{Q}} = \mathcal{U} \cup \bigcup_{\mathcal{T} \in \overline{\pi} \backslash \mathcal{U}} \mathcal{T}
\end{align*}

\begin{algorithm}[H]
\caption{Join-Poly}\label{join-poly}
\begin{algorithmic}[1]
\Function{Join-Poly}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{O}, \pi_{\mathcal{O}}$}
\State$\overline{\pi}$ := $\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}$
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P, \pi_{\mathcal{P}}, \overline{\pi}}$}
\State$\mathcal{Q}'$ := \Call{Refactor}{$\mathcal{Q, \pi_{\mathcal{Q}}, \overline{\pi}}$}
\For{\textbf{each} $i$ \textbf{in} $\{0,...,|\mathcal{P}'|\}$}
\If{$\mathcal{P}'_i = \mathcal{Q}'_i$}
\State$\mathcal{O}$.add$(\mathcal{P}'_{i})$
\State$\pi_{\mathcal{O}}$.add$(\mathcal{X}'_{i})$
\Else
\State$\mathcal{X}_{\mathcal{T}}$ := $\mathcal{X}_{\mathcal{T}} \cup \overline{\pi}_{i}$
\State$\mathcal{P}_{\mathcal{T}}$ := $\mathcal{P}_{\mathcal{T}} \bowtie \mathcal{P}'_{i}$
\State$\mathcal{Q}_{\mathcal{T}}$ := $\mathcal{Q}_{\mathcal{T}} \bowtie \mathcal{Q}'_{i}$
\EndIf
\EndFor
\State$\mathcal{P}_{\mathcal{T}}$ := $\mathcal{P}_{\mathcal{T}} \sqcap \mathcal{Q}_{\mathcal{T}}$
\State$\pi_{\mathcal{O}}$.add$(\mathcal{X}_{\mathcal{T}})$
\State$\mathcal{O}$.add$(\mathcal{P}_{\mathcal{T}})$
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\chapter{Implementazione}
\label{sec:org57efcce}
Qui andremo a parlare dell'implementazione concreta dei poliedri fattorizzati e
delle loro operazioni. In particolare, i metodi che modificano il poliedro
sono stati implementati utilizzando i già presenti, funzionanti e testati metodi
della \emph{PPLite}. L'implementazione data è quindi da vedere come un \textbf{wrapper} di
quest'ultima.

\section{\texttt{F\_Poly}}
\label{sec:org519c5b8}
La classe dove sono compresi gran parte dei medoti è \texttt{F\_Poly}. È stata
definita nel file \texttt{F\_Poly.hh} dove sono presenti 92 metodi pubblici e 14 metodi
privati. I più significativi sono:

\begin{itemize}
\item Un costruttore esplicito, un costruttore per copia, un costruttore per spostamento
\item Operazioni di assegnamento per copia e per spostamento
\item Un metodo \texttt{check\_inv()} per controllare che le invarianti di classe non siano
state violate
\item ??
\item Funzioni di appoggio per gestire il poliedro
\end{itemize}

Sono inoltre presenti delle stutture dati per la gestione dei fattori:

\begin{itemize}
\item \texttt{Block}: un \texttt{std::vector} di \texttt{dim\_type} che rappresenta un blocco \(X_i\) che
contiene alcune dimensioni del poliedro
\item \texttt{Blocks}: un \texttt{std::vector} di \texttt{Block} che esprimono le partizioni del poliedro
\item \texttt{Factor}: un fattore è un poliedro, \texttt{Factor} è un alias per oggetti di tipo \texttt{Poly}
\item \texttt{Factors}: un \texttt{std::vector} di \texttt{Factor}
\end{itemize}

Sono inoltre presenti tre variabili:

\begin{itemize}
\item \texttt{dim\_type dim}: indicante le dimensioni del poliedro
\item \texttt{Topol topol}: indicante la topologia del poliedro
\item \texttt{bool is\_empty}: indicante se il poliedro è o meno vuoto
\end{itemize}

\subsection{\texttt{check\_inv()}}
\label{sec:orgd13673e}
Il metodo menzionato contiene tutti i controlli necessari per verificare che
l'invariante di classe non sia stata violata, e che quindi il poliedro su cui si
sta lavorando è in condizioni di correttezza. Le invarianti di classe che devono
essere rispettate sono le seguenti:

\begin{itemize}
\item La dimensione minima del poliedro deve essere \(\ge 0\)
\begin{minted}[]{c++}
if (dim < 0) {
  reason = "F_Poly broken: invalid space dimension";
  maybe_dump();
  return false;
}
\end{minted}
\item Se il poliedro è vuoto, i fattori e i blocchi devono essere anch'essi vuoti
\begin{minted}[]{c++}
if (is_empty()) {
  if (!(factors.empty() && blocks.empty())) {
    reason = "F_Poly broken: empty polyhedron has factors";
    maybe_dump();
    return false;
  }
  // No other check for an empty polyhedron.
  return true;
}
\end{minted}
\item Il numero di blocchi deve essere uguale al numero di fattori
\begin{minted}[]{c++}
if (factors.size() != blocks.size()) {
  reason = "F_Poly broken: #factors != #blocks";
  maybe_dump();
  return false;
}
\end{minted}
\item La cardinalità dei blocchi deve essere uguale a \texttt{dim}
\begin{minted}[]{c++}
dim_type dim_ = 0;
for (const auto& block : blocks)
  dim_ += block.size();
if (dim != dim_) {
  reason = "F_Poly broken: space dimension mismatch";
  maybe_dump();
  return false;
}
\end{minted}
\item Le dimensioni di un fattore devono essere uguali alle dimensioni del blocco
che lo rappresenta
\begin{minted}[]{c++}
// Each factor space dim should match its block.
for (dim_type i = 0; i < num_rows(factors); ++i) {
  if (factors[i].space_dim() != num_rows(blocks[i])) {
    reason = "F_Poly broken: factor vs block space dim mismatch";
    maybe_dump();
    return false;
  }
}
\end{minted}
\item Nessun fattore deve essere vuoto
\begin{minted}[]{c++}
if (std::any_of(factors.begin(), factors.end(),
                std::mem_fn(&Poly::is_empty))) {
  reason = "F_Poly broken: empty factor";
  maybe_dump();
  return false;
}
\end{minted}
\item Ogni dimensione dello spazio deve apparire una e una volta soltanto nei
blocchi e non devono esserci blocchi vuoti
\begin{minted}[]{c++}
std::vector<bool> dims(dim, false);
for (const auto& block : blocks) {
  if (block.size() == 0) {
    reason = "F_Poly broken: found empty block";
    maybe_dump();
    return false;
  }
  for (const auto d : block) {
    if (d < 0 || d >= dim) {
      reason = "F_Poly broken: block contains an illegal
                space dim";
      maybe_dump();
      return false;
    }
    if (dims[d]) {
      reason = "F_Poly broken: repeated space dim in blocks";
      maybe_dump();
      return false;
    }
    dims[d] = true;
  }
}
\end{minted}
\item Ogni dimensione dello spazio deve essere presente in un blocco
\begin{minted}[]{c++}
if (std::find(dims.begin(), dims.end(), false) != dims.end()) {
  reason = "F_Poly broken: a space dim is missing from blocks";
  maybe_dump();
  return false;
}
\end{minted}
\end{itemize}

\section{Operazione di base}
\label{sec:orgc800e93}
Le funzioni più significative di \texttt{F\_Poly} sono state implementate più ad alto
livello, sfruttando le funzioni già implementate e funzionanti della \emph{PPLite}.
Questo ha permesso di avere tempi di sviluppo più tempestivi e una fase di
testing meno problematica. Le funzioni principali, in parte discusse nel
capitolo uno, sono:

\begin{minted}[]{c++}
static Factors refactor(const Factors& f,
                        const Blocks& b1, const Blocks& b2);
static Blocks least_upper_bound(const Blocks& b1, const Blocks& b2);
static Blocks merge(const Blocks& b, const Block& added);
\end{minted}

\subsection{Refactoring}
\label{sec:org8384767}


\chapter{Conclusione}
\label{sec:org17a0f3b}
\end{document}

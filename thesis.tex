% Created 2019-02-18 lun 17:16
% Intended LaTeX compiler: pdflatex
\documentclass{mimosis}
 \usepackage{minted}
 \addto\captionsenglish{\renewcommand\contentsname{Indice}}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{float}
\usepackage[noend]{algpseudocode}
\KOMAoptions{fontsize=12pt,headings=normal}
\makeglossaries
\theoremstyle{definition}
\newtheorem{exmp}{Esempio}[section]
\usepackage{amsmath}
\floatname{algorithm}{Algoritmo}

\newcommand{\mboxparagraph}[1]{\paragraph{#1}\mbox{}\\}
\newcommand{\mboxsubparagraph}[1]{\subparagraph{#1}\mbox{}\\}
\author{Luigi Zaccone}
\date{\today}
\title{La fattorizzazione cartesiana nella libreria PPLite}
\hypersetup{
 pdfauthor={Luigi Zaccone},
 pdftitle={La fattorizzazione cartesiana nella libreria PPLite},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.1 (Org mode 9.2)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents



\chapter{Introduzione}
\label{sec:orga216e26}

\chapter{Fattorizzazione cartesiana}
\label{sec:org137d6d0}
La fattorizzazione cartesiana permette di avere una complessità di esecuzione
minore sulle operazioni applicate ai poliedri. L'idea è che i poliedri
utilizzati nell'analisi dei programmi non mettono in relazione tutte le
variabili del programma in un solo vincolo. Per esempio: un ipercubo \\
\(H_n = \{0 \le x_i \le 1 \; | \; i = 1,...,n\}\)
richiede \(2^n\) generatori per essere rappresentato, tramite la decomposizione
invece ne sono necessari solo \(2n\). La terminologia e gli esempi saranno
ispirati al lavoro svolto in \cite{fastpoly}.

\section{Blocchi e fattori}
\label{sec:orgd454245}
Sia \(\mathcal{X} = \{x_1, x_2,..., x_n\}\) un insieme di \(n\) variabili. Dato un poliedro, \(\mathcal{X}\)
può essere partizionato in un sottoinsieme \(\mathcal{X}_k\) che chiamiamo \emph{blocchi} tale
che i vincoli esistono solo tra variabili presenti nello stesso \emph{blocco}.
Quindi, ogni variabile priva di vincoli risiede in un singoletto. Ci riferiamo a
questo insieme come \(\pi = \pi_P = \{\mathcal{X}_1, \mathcal{X}_2,..., \mathcal{X}_t\}\).

\begin{exmp}
Consideriamo
\begin{align*}
  &\mathcal{X} = \{x_1, x_2, x_3\} ~{}e \\
  &P = \{x_1 + 2x_2 \le 3\}.
\end{align*}

In questo caso $\mathcal{X}$ viene partizionato in due blocchi: $\mathcal{X}_1 = \{x_1, x_2\}$ e
$\mathcal{X}_2 = \{x_3\}$.
\end{exmp}

Per ogni blocco, quindi, sarà presente un \emph{fattore} \(P_k\) che sarà composto solo
dalle variabili presenti nel suo blocco. In qualsiasi momento il poliedro
originale può essere recuperato applicando l'unione dei vincoli
\(\mathcal{C}_{P_k}\) e il prodotto cartesiano dei generatori \(\mathcal{G}_{P_k}\).

\begin{exmp}
  Consideriamo un poliedro $\mathcal{P}$ con i seguenti vincoli e generatori:
  \begin{align*}
    &\mathcal{C} = \{-x_{1} \le -1, x_{1} \le 4, -x_{2} \le -2, x_{2} \le 4\} \\
    &\mathcal{G} = \{\{(1),(2)\}, \{(1),(4)\}, \{(4),(2)\}, \{(4),(4)\}\}
  \end{align*}
  Il poliedro non ha vincoli tra le variabili $x_1$ e $x_2$. Quindi, $\mathcal{X} = \{x_1,x_2\}$
  può essere partizionato nei blocchi: $\pi_P = \{\{x_1\}, \{x_2\}\}$ con i risultanti fattori
  $P_1 = (\mathcal{C}_{P_1}, \mathcal{G}_{P_1})$ e $P_2 = (\mathcal{C}_{P_2}, \mathcal{G}_{P_2})$ dove:
  \begin{align*}
      &\mathcal{C}_{P_{1}} = \{-x_{1} \le -1, x_{1} \le 4\}  &&\mathcal{C}_{P_{2}} = \{ -x_{2} \le -2, x_{2} \le 4\} \\
      &\mathcal{G}_{P_{1}} = \{\{(1),(4)\}, \emptyset, \emptyset \} &&\mathcal{G}_{P_{2}} = \{\{(2),(4)\}, \emptyset, \emptyset \}
  \end{align*}
  Il poliedro originale può essere ricavato da $P_{1}$ e $P_{2}$ come
  P = $P_{1} \bowtie P_{2} = (\mathcal{C}_{P_{1}} \cup \mathcal{C}_{P_{2}}, \mathcal{G}_{P_{1}} \times \mathcal{G}_{P_{2}})$
\end{exmp}

L'insieme \(\mathcal{L}\) che consiste in tutte le partizioni possibili di \(\mathcal{X}\)
forma un \emph{reticolo di partizioni} \((\mathcal{L}, \sqsubseteq, \sqcup, \sqcap,
\bot, \top)\). Gli elementi \(\pi\) del reticolo sono ordinati come segue: \(\pi
\sqsubseteq \pi'\), se ogni blocco di \(\pi\) è incluso in qualche blocco di
\(\pi'\). Questo reticolo contiene anche i soliti operatori di \emph{least upper bound}
\((\sqcup)\) e \emph{greatest upper bound} \((\sqcap)\). È da notare che nel reticolo della
partizione \(\top = \{\mathcal{X}\}\) e \(\bot = \{\{x_1\}, \{x_2\}, ..., \{x_n\}\}\).

\section{Partizione ammissibile}
\label{sec:org085e556}
Una partizione \emph{ammissibile} \(\overline{\pi}\) è tale se, dato un poliedro P, non esistono
variabili \(x_i\) e \(x_j\) in diversi blocchi di \(\pi\) relazionati da un vincolo di
P, ovvero \(\pi \sqsupseteq \pi_P\). Le partizioni ammissibili sono un
sottoinsieme chiuso superiormente del reticolo, chiameremo questo sottoinsieme
\(\mathcal{B}\). Se \(\overline{\pi} \in \mathcal{B}\) allora lo saranno anche tutte
le \(\overline{\pi}'\) tali che \(\overline{\pi}, \overline{\pi}' \in \mathcal{L}\) e
\(\overline{\pi} \sqsubseteq \overline{\pi}'\). Le partizioni ammissibili sono
dotate di elemento minimo ovvero la più fine partizione appartenente a
\(\mathcal{B}\), partizione che verrà anche considerata come la migliore. Questa
partizione minima viene calcolata come spiegato nell'\textbf{esempio 2.1.1}.

Il nostro obiettivo è quello di cercare di utilizzare sempre la partizione
ammissibile minima.
\section{Operazioni}
\label{sec:org9430b47}
In questo paragrafo verrà spiegato l'effetto che alcune operazioni dei poliedri
generano sui fattori. Innanzitutto è fondamentalche che, nelle operazioni
binarie, i poliedri abbiano lo stesso numero di dimensioni. Per descrivere
meglio queste operazioni, è necessario prima dare una specifica di alcune
funzioni utilizzate all'interno delle prime.
\(\\\)
\(\\\)
\-\hspace{0.1cm} \textbf{Convert Constraint.} Funzione che mappa le dimensioni di un vincolo o
generatore all'interno di un fattore. La PPLite utilizza dimensioni nel range
\([0, ..., n]\) per i poliedri. Tramite la fattorizzazione è quindi necessario
tradurre gli indici esterni a quelli interni dei vari blocchi.
\(\\\)
\(\\\)
\-\hspace{0.1cm} \textbf{Least Upper Bound.} Questa funzione estrae il \emph{lub} di due partizioni.
Dall'Algoritmo 1 si può notare come sia necessario generare l'insieme delle
unioni dei due blocchi \(\pi_{\mathcal{P}}\) e \(\pi_{\mathcal{Q}}\) in
\(\overline{\pi}\). Successivamente si uniscono tra loro tutti i blocchi di
\(\overline{\pi}\) che hanno un'intersezione non vuota, calcolando
successivamente la partizione corretta.
\begin{algorithm}[H]
  \caption{Least-Upper-Bound}\label{lub}
  \begin{algorithmic}[1]
    \Function{Least-Upper-Bound}{$\pi_{\mathcal{P}}, \pi_{\mathcal{Q}}$}
    \State $\overline{\pi} := \emptyset$
    \For{\textbf{each} $\mathcal{X}_{\mathcal{P}i}$ \textbf{in} $\pi_{\mathcal{P}}$}
    \State$\mathcal{A}$:= $\emptyset$
    \For{\textbf{each} $\mathcal{X}_{\mathcal{Q}k} in \pi_{\mathcal{Q}}$}
    \If{$\mathcal{X}_{\mathcal{P}i} \cap\mathcal{X}_{\mathcal{Q}k} \ne \emptyset$}
    \State$\mathcal{A}:=\mathcal{B} \cup\mathcal{X}_{\mathcal{Q}k}$
    \EndIf
    \EndFor
    \State $\overline{\pi}$.add($\mathcal{A}$)
    \EndFor
    \While{$\exists$ coppie ($\overline{\pi}_i, \overline{\pi}_j$), $i \ne j$ \textbf{t.c.} $\overline{\pi}_i \cap \overline{\pi}_j \ne \emptyset$}
    \State $\overline{\pi}$ := $\ \{\overline{\pi}_i, \overline{\pi}_j\} \cup \{\overline{\pi}_i \cup \overline{\pi}_j\}\}$
    \EndWhile
    \Return $\overline{\pi}$
    \EndFunction
  \end{algorithmic}
\end{algorithm}
\(\\\)
\(\\\)
\-\hspace{0.1cm} \textbf{Merge.} Definito come \(\uparrow\), quando si ha l'operazione
\(\pi \uparrow \mathcal{A}\), dove \(\pi\) è una partizione di un poliedro e
\(\mathcal{A}\) è un sottoindieme delle sue variabili (non per forza connesse da
vincoli), genera una partizione \(\pi_{merge}\) tale che:

\begin{itemize}
\item \(\exists\) \(\mathcal{X}_i \in \pi_{merge} : \mathcal{A} \subseteq \mathcal{X}_i\)
\item \(\pi \sqsubseteq \pi_{merge}\)
\end{itemize}

Viene quindi generata una nuova fattorizzazione unendo i blocchi del poliedro
che hanno variabili in comune con \(\mathcal{A}\). Questa unione genera un blocco
unico \(\mathcal{D}\), tale che \(\mathcal{A} \subseteq \mathcal{B}\).

\begin{algorithm}[H]
\caption{Merge}\label{merge}
\begin{algorithmic}[1]
\Function{Merge}{$\pi, \mathcal{A}$}
\State$\pi_{\mathcal{O}} := \emptyset$
\State$\mathcal{D} := \emptyset$
\For{\textbf{each} $\mathcal{X}_{i}$ \textbf{in} $\pi$}
\If{$\mathcal{X}_{i} \cap \mathcal{A} \ne \emptyset$}
\State$\mathcal{D} := \mathcal{D} \cup \mathcal{X}_{i}$
\Else
\State$\pi_{\mathcal{O}}$.add$(\mathcal{X}_{i})$
\EndIf
\EndFor
\State$\pi_{\mathcal{O}}$.add$(\mathcal{D})$
\State\textbf{return} $\pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\-\hspace{0.1cm} \textbf{Refactor.} Questa operazione ha come argomenti un poliedro
fattorizzato e una fattorizzazione ammissibile \(\overline{\pi}\) per questo
poliedro. Non fa altro che convertire i fattori rispetto alla seconda
fattorizzazione. È importante notare che la partizione ammissibile non sarà più
fine di \(\pi_{\mathcal{P}}\), visto che i blocchi non vengono divisi bensì solo
uniti.

La refactor è un'operazione necessaria in quanto, avendo due poliedri
\(\mathcal{P}\) e \(\mathcal{Q}\) definiti sullo stesso insieme di variabili \(X =
\{x_1, x_2, ..., x_n\}\) e presi \(\overline{\pi}_{\mathcal{P}} =
\{X_{\mathcal{P}_1}, X_{\mathcal{P}_2}, ..., X_{\mathcal{P}_r}\}\),
\(\overline{\pi}_{\mathcal{Q}} = \{X_{\mathcal{Q}_1}, X_{\mathcal{Q}_2}, ...,
X_{\mathcal{Q}_s}\}\)
partizioni corrette di \(\mathcal{P}\) e \(\mathcal{Q}\) in genere abbiamo che
\(\overline{\pi}_{\mathcal{P}} \ne \overline{\pi}_{\mathcal{Q}}\). È necessario
che, come in molte operazioni comuni nell'analisi e manipolazione dei poliedri,
le dimensioni delle partizioni utilizzate siano uguali in quantità e valori. Se
si applica la fattorizzazione su poliedri aventi gli stessi blocchi non si fa
altro che calcolare il \emph{lub} (\(\overline{\pi} = \overline{\pi}_{\mathcal{P}}
\; \sqcup \; \overline{\pi}_{\mathcal{Q}}\)).

\begin{algorithm}[H]
\caption{Refactor}\label{refactor}
\begin{algorithmic}[1]
\Function{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \overline{\pi}$}
\State$\mathcal{O}, \pi_{\mathcal{O}} := \emptyset$
\For{\textbf{each} $i$ \textbf{in} $\{1,..., r\}$} \Comment{r = numero blocchi di $\pi_{\mathcal{P}}$}
\State$\mathcal{O}_{i}, \pi_{\mathcal{O}i} := \emptyset$
\For{\textbf{each} $j$ \textbf{in} $\{1,...,m\}$} \Comment{m = numero blocchi di $\overline{\pi}$}
\If{$\pi_{\mathcal{P}i} \cap \overline{\pi}_{i} \ne \emptyset$}
\State$\mathcal{O}_{i}$ := $\mathcal{O}_{j} \bowtie \mathcal{P}_{i}$
\State$\pi_{\mathcal{O}i}$ := $\pi_{\mathcal{O}i} \bowtie \pi_{\mathcal{P}i}$
\EndIf
\EndFor
\State$\mathcal{O}$.add$(\mathcal{O}_{i})$
\State$\pi_{\mathcal{O}}$.add$(\pi_{\mathcal{O}i})$
\EndFor
\State\Call{Remap-Dimensions}{$\mathcal{O}, \pi_{\mathcal{O}}, \overline{\pi}$}
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

Come spiegato precedentemente, la refactor prende in input un poliedro
fattorizzato \(\mathcal{P}\) e la sua partizione \(\pi_{\mathcal{P}}\) per
rifattorizzarlo in base al terzo parametro \(\overline{\pi}\). Non fa altro che
unire i fattori che hanno intersezione dei relativi blocchi non vuota tra
\(\pi_{\mathcal{P}}\) e \(\overline{\pi}\) e generare il blocco finale. È importante
ri-mappare le dimensioni dei fattori di output in base a quelle descritte nel
blocco di \(\overline{\pi}\).

\subsection{Inclusion Test (\(\sqsubseteq\))}
\label{sec:org5f78bc5}
Operazione necessaria per controllare se un poliedro è incluso in un altro,
disponendo di una doppia rappresentazione è possibile controllarlo se, dati due
poliedri \(\mathcal{P}\) e \(\mathcal{Q}\) tutti i generatori in
\(\mathcal{G}_{\mathcal{P}}\) soddisfano tutti i vincoli in
\(\mathcal{C}_{\mathcal{Q}}\).

Nel nostro caso e, come mostrato nell'Algoritmo 4, è stata implementata tramite
wrapper. In particolare vengono rifattorizzati i poliedri con il \emph{lub}
\(\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}\) e successivamente viene applicata
l'\emph{inclusion} in ordine su ogni coppia di fattori: il test avrà successo se
tutti i test ritornano \emph{True}.

\begin{algorithm}[H]
\caption{Inclusion Test}\label{inclusion test}
\begin{algorithmic}[1]
\Function{Inclusion}{$\mathcal{P},\pi_{\mathcal{P}},\mathcal{Q},\pi_{\mathcal{Q}}$}
\State$\overline{\pi}$ := \Call{Leas-Upper-Bound}{$\pi_{\mathcal{P}},\pi_{\mathcal{Q}}$}
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \overline{\pi}$}
\State$\mathcal{Q}'$ := \Call{Refactor}{$\mathcal{Q}, \pi_{\mathcal{Q}}, \overline{\pi}$}
\For{\textbf{each} $k$ \textbf{in} $\{1,...,r\}$} \Comment{r = numero di blocchi in $\overline{\pi}$}
\If{$\mathcal{P}'_{k}$ non include $\mathcal{Q}'_{k}$ }
\State\Return\textit{False}
\EndIf
\EndFor
\State\Return\textit{True}
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Join (\(\sqcup\))}
\label{sec:orgf7433f1}
Tramite la doppia reppresentazione, i generatori \(\mathcal{G}_{\mathcal{O}}\)
dove \(\mathcal{O}\) è il risultato del \emph{join}, sono semplicemente l'unione dei
generatori dei poliedri presi in input dalla funzione, ovvero
\(\mathcal{G}_{\mathcal{O}}\) = \(\mathcal{G}_{\mathcal{P}} \cup
\mathcal{G}_{\mathcal{Q}}\). I vincoli \(\mathcal{C}_{\mathcal{O}}\) sono ottenuti
aggiungendo incrementalmente i generatori di \(\mathcal{G}_{\mathcal{Q}}\) al
poliedro definito da \(\mathcal{C}_{\mathcal{P}}\).

\begin{algorithm}[H]
\caption{Join}\label{join}
\begin{algorithmic}[1]
\Function{Join}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{O}, \pi_{\mathcal{O}}$}
\If{\Call{is\_empty}{$\mathcal{P}$}}
\State$\mathcal{O}, \pi_{\mathcal{O}}$ := $\mathcal{Q}, \pi_{\mathcal{Q}}$
\ElsIf{\Call{is\_empty}{$\mathcal{Q}$}}
\State$\mathcal{O}, \pi_{\mathcal{O}}$ := $\mathcal{P}, \pi_{\mathcal{P}}$
\Else
\State$\mathcal{O}, \pi_{\mathcal{O}}$ := \Call{Join-Poly}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{O}, \pi_{\mathcal{O}}$}
\EndIf
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

Avendo un sistema di poliedri fattorizzati, è necessario per prima cosa
rifattorizzare \(\mathcal{P}\) e \(\mathcal{Q}\) utilizzando il loro \emph{lub}. Per ogni
coppia di fattori \((\mathcal{P}'_{i}, \mathcal{Q}'_{i})\) uguali, se ne aggiunge
uno con il rispettivo blocco \(\overline{\pi}_i\) al risultato. Se invece i due
fattori risultano diversi, ognuno viene unito a un fattore comune
\((\mathcal{P}'_{i}, \mathcal{Q}'_{i})\) e successivamente si calcola la \emph{join} di
questi due fattori e si inserisce insieme al rispettivo blocco nel poliedro di
output.

Un caso speciale è stato assegnato ai poliedri \emph{vuoti}. Dati \(\mathcal{P}\) come
poliedro \emph{vuoto} e \(\mathcal{Q}\) un poliedro generico allora \(\mathcal{Q} \cup
\mathcal{P}\) = \(\mathcal{Q}\) e anche \(\mathcal{P} \cup
\mathcal{Q}\) = \(\mathcal{Q}\).

Se invece \(\overline{\pi} = \overline{\pi}_{\mathcal{P}} \sqcup
\overline{\pi}_{\mathcal{Q}}\) e \(\mathcal{U} = \{\mathcal{X}_k \: | \: \mathcal{P}
= \mathcal{Q}, \mathcal{X}_k \in \overline{\pi} \}\) allora la partizione
ammissibile, in questo caso, sarà uguale a:

\begin{align*}
\overline{\pi}_{\mathcal{P} \sqcup \mathcal{Q}} = \mathcal{U} \cup \bigcup_{\mathcal{T} \in \overline{\pi} \backslash \mathcal{U}} \mathcal{T}
\end{align*}

\begin{algorithm}[H]
\caption{Join-Poly}\label{join-poly}
\begin{algorithmic}[1]
\Function{Join-Poly}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{O}, \pi_{\mathcal{O}}$}
\State$\overline{\pi}$ := $\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}$
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P, \pi_{\mathcal{P}}, \overline{\pi}}$}
\State$\mathcal{Q}'$ := \Call{Refactor}{$\mathcal{Q, \pi_{\mathcal{Q}}, \overline{\pi}}$}
\For{\textbf{each} $i$ \textbf{in} $\{0,...,|\mathcal{P}'|\}$}
\If{$\mathcal{P}'_i = \mathcal{Q}'_i$}
\State$\mathcal{O}$.add$(\mathcal{P}'_{i})$
\State$\pi_{\mathcal{O}}$.add$(\mathcal{X}'_{i})$
\Else
\State$\mathcal{X}_{\mathcal{T}}$ := $\mathcal{X}_{\mathcal{T}} \cup \overline{\pi}_{i}$
\State$\mathcal{P}_{\mathcal{T}}$ := $\mathcal{P}_{\mathcal{T}} \bowtie \mathcal{P}'_{i}$
\State$\mathcal{Q}_{\mathcal{T}}$ := $\mathcal{Q}_{\mathcal{T}} \bowtie \mathcal{Q}'_{i}$
\EndIf
\EndFor
\State$\mathcal{P}_{\mathcal{T}}$ := $\mathcal{P}_{\mathcal{T}} \sqcap \mathcal{Q}_{\mathcal{T}}$
\State$\pi_{\mathcal{O}}$.add$(\mathcal{X}_{\mathcal{T}})$
\State$\mathcal{O}$.add$(\mathcal{P}_{\mathcal{T}})$
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Meet (\(\sqcap\))}
\label{sec:org04fbf9f}
Per la doppia rappresentazione, \(\mathcal{P} \sqcap \mathcal{Q}\) genera un
poliedro i cui vincoli \(\mathcal{C}_{\mathcal{P} \sqcap \mathcal{Q}}\) sono
risultati dall'unione di \(\mathcal{C}_{\mathcal{P}}\) e
\(\mathcal{C}_{\mathcal{Q}}\), mentre \(\mathcal{G}_{\mathcal{P} \sqcap
\mathcal{Q}}\) si ottiene aggiungendo incrementalmente i vincoli di
\(\mathcal{C}_{\mathcal{Q}}\) al poliedro \(\mathcal{P}\). Se \(\mathcal{P} \sqcap
\mathcal{Q}\) risulta non soddisfacibile allora \(\mathcal{P} \sqcap \mathcal{Q} =
\bot\) e \(\mathcal{G}_{\mathcal{P} \sqcap \mathcal{Q}} = \emptyset\).

Per quanto riguarda i poliedri fattorizzati è necessario generare
\(\overline{\pi} = \overline{\pi}_{\mathcal{P}} \sqcap
\overline{\pi}_{\mathcal{Q}}\) e rifattorizzare i due poliedri \(\mathcal{P}\) e
\(\mathcal{Q}\) tramite essa, generando quindi \(\mathcal{P}'\) e \(\mathcal{Q}'\).
Per tutte le \(r\) coppie di fattori \(\mathcal{P}'_i\) e \(\mathcal{Q}'_i\), se
sono uguali aggiungo \(\mathcal{P}'_i\) con il rispettivo blocco al poliedro di
output \(\mathcal{O}\), altrimenti creo un fattore \(\mathcal{F} = \mathcal{P}'_i
\sqcap \mathcal{Q}'_i\). Se \(\mathcal{F}\) dovesse risultare vuoto, allora il
risultato dell'intera operazione di \emph{meet} sarebbe un poliedro \(\bot\). Se al
contrario non fosse vuoto, aggiungo \(\mathcal{F}\) a \(\mathcal{O}\) per poi
riprender il ciclo fino all'esaurimento dei fattori e ritornando infine
\(\mathcal{O}\) e il suo blocco (rappresentato dal \emph{lub} di \(\pi_{\mathcal{P}}\) e
\(\pi_{\mathcal{Q}}\)) come risultato. \(\overline{\pi}_{\mathcal{P} \sqcap
\mathcal{Q}} = \pi_{\mathcal{P}} \sqcap \pi_{\mathcal{Q}}\) è una partizione
ammissibile se \(\mathcal{P} \sqcap \mathcal{Q} \ne \bot\), altrimenti \(\bot\) è
ammissibile.

\begin{algorithm}[H]
\caption{Meet}\label{meet}
\begin{algorithmic}[1]
\Function{Meet}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{Q}, \pi_{\mathcal{Q}}$}
\State$\overline{\pi}$ := $\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}$
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \overline{\pi}$}
\State$\mathcal{Q}'$ := \Call{Refactor}{$\mathcal{Q}, \pi_{\mathcal{Q}}, \overline{\pi}$}
\State$\mathcal{O}$ := $\emptyset$
\For{\textbf{each} $i$ \textbf{in} $\{1,...,r\}$}\Comment{r = numero di blocchi in $\overline{\pi}$}
\If{$\mathcal{P}'_i = \mathcal{Q}'_i$}
\State$\mathcal{O}$.add$(\mathcal{P}'_i)$
\Else
\State$\mathcal{F}$ := $\mathcal{P}'_{i} \bowtie \mathcal{Q}'_{i}$
\If{\Call{is\_empty}{$\mathcal{F}$}}
\State\Return$\bot, \bot$
\EndIf
\State$\mathcal{O}$.add$(\mathcal{F})$
\EndIf
\EndFor
\State$\pi_{\mathcal{O}}$ := $\overline{\pi}$
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}


\subsection{Conditional}
\label{sec:org2b2f7b0}
Questa operazione viene utilizzata per aggiungere nuovi vincoli tra le variabili
di un poliedro. Tramite la doppia rappresentazione è possibile aggiungendo un
vincolo arbitrario \(c\) all'insieme \(\mathcal{C}_{\mathcal{P}}\). Se dopo
l'inserimento il sistema di vincoli risulta insoddisfacibile allora il poliedro
diventa vuoto. Il sistema di generatori è, come sempre, ricavato dall'aggiunta
incrementale del vincolo \(c\) nel poliedro attraverso la conversione.

Utilizzando poliedri fattorizzati è necessare ricavare il blocco \(\mathcal{B}\) che contiene le
variabili utilizzate nel vincolo, rifattorizzando \(\mathcal{P}\) con
\(\overline{\pi}_{\mathcal{P}} \uparrow \mathcal{B}\) si genera \(\mathcal{P}'\).
Successivamente bisogna prendere il fattore relativo contenente le variabili di
\(\mathcal{B}\), convertire il vincolo con le dimensioni \emph{interne} del fattore e
aggiungerlo a quest'ultimo utilizzando un'operazione per normali poliedri. Si
controlla, infine, che il sistema di vincoli sia ancora soddisfacibile e, in
caso negativo i blocchi e i fattori in \(\bot\) vengono modificati e il poliedro
si rende \emph{vuoto}. È importante far notare che, dato \(\mathcal{O}\) un poliedro
risultante dall'aggiunta di un vincolo, \(\overline{\pi}_{\mathcal{O}} = \overline{\pi}_{\mathcal{P}}
\uparrow \mathcal{B}\) è ammissibile se \(\mathcal{O} \ne \bot\), altrimenti
\(\overline{\pi}_{\mathcal{O}} = \bot\).

\begin{algorithm}[H]
\caption{Conditional}\label{conditional}
\begin{algorithmic}[1]
\Function{Conditional}{$con$}
\State$\mathcal{B}$ := \Call{extract\_block}{$\mathcal{P}$, $\pi_{\mathcal{P}}$, \textit{con}}
\State$\overline{\pi}$ := $\pi_{\mathcal{P}} \uparrow \mathcal{B}$
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \overline{\pi}$}
\For{\textbf{each} $i$ \textbf{in} $\{1,...,r\}$}\Comment{r = numero di blocchi in $\overline{\pi}$}
\If{$\mathcal{B} \cap \overline{\pi}_i \ne \emptyset$}
\State$con_{int}$ := \Call{convert\_con}{$\overline{\pi}_i$, \textit{con}}
\State$\mathcal{F}$ := \Call{add\_con}{$\mathcal{P}'_i, con_{int}$}
\State$\mathcal{O}$.add$(\mathcal{F})$
\If{\Call{is\_empty}{$\mathcal{O_{i}}$}}
\State\Return$\bot, \bot$
\EndIf
\State$\mathcal{O}$.add$(\mathcal{P'_i})$
\EndIf
\EndFor
\State$\pi_{\mathcal{O}}$ := $\overline{\pi}$
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Assignment}
\label{sec:org1846553}
Per quanto riguarda il dominio dei poliedri fattorizzati, l'operazione di
\emph{assignment} è molto simile alla \emph{conditional}. Dopo aver estratto il blocco
\(\mathcal{B}\) che indica le variabili utilizzate nell'espressione lineare, si
fattorizza il poliedro \(\mathcal{P}\) con \(\overline{\pi}_{\mathcal{P}} =
\pi_{\mathcal{P}} \uparrow \mathcal{B}\) ottenendo \(\mathcal{P}'\),
successivamente si prende il blocco con le variabili di \(\mathcal{B}\) e si
applica al relativo fattore un \emph{assignment} come per i poliedri non
fattorizzati, rimappando correttamente le variabili esterne rispetto a quelle
interne al fattore. La partizione ammissibile per un poliedro risultante da
questa operazione è \(\overline{\pi}_{\mathcal{P}} \uparrow \mathcal{B}\).

\begin{algorithm}[H]
\caption{Assignment}\label{assignment}
\begin{algorithmic}[1]
\Function{Assignment}{$\mathcal{P}$, $\pi_{\mathcal{P}}, stmt$}
\State let $stmt = (x_{i} = ax + \epsilon) $
\State$\mathcal{B}$ := \Call{extract\_block}{$stmt$}
\State$\overline{\pi}$ := $\pi_{\mathcal{P}} \uparrow \mathcal{B}$
\State$\mathcal{P}'$ := \Call{refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \overline{\pi}$}
\For{\textbf{each} $i$ \textbf{in} $\{1,...,r\}$}\Comment{$r = |\mathcal{P}|$}
\If{$\overline{\pi}_i \subseteq \mathcal{B}$}
\State$stmt_{int}$ := \Call{convert}{$\overline{\pi}, stmt$}
\State$\mathcal{F}$ := \Call{assignment}{$\mathcal{P}'_i, stmt_{int}$}\Comment{Poliedri non fattorizzati}
\State $\mathcal{O}$.add$(\mathcal{F})$
\If{$\mathcal{P}'_i$ := $\emptyset$}
\State\Return$\bot,\bot$
\EndIf
\Else
\State $\mathcal{O}$.add$(\mathcal{P}'_i)$
\EndIf
\EndFor
\State\Return $\mathcal{O}, \overline{\pi}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Widening (\(\nabla\))}
\label{sec:org4901834}
Per la doppia rappresentazione, l'operatore di \emph{widening} necessità come
parametri i generatori e i vincoli di \(\mathcal{P}\) e i vincolo di
\(\mathcal{Q}\). Il risultato dell'operazione \(\mathcal{P} \nabla
\mathcal{Q}\) conterrà i vincoli \(\mathcal{C}_{\mathcal{Q}}\) che sono presenti in
\(\mathcal{C}_{\mathcal{P}}\) o che possono sostituirne un vincolo senza cambiare
\(\mathcal{P}\).

Per implementarlo è necessario effettuare uan rifattorizzazione \(\mathcal{P}'\)
del primo argomento \(\mathcal{P}\) con \(\overline{\pi} = \pi_{\mathcal{P}} \sqcup
\pi_{\mathcal{Q}}\), mentre non è necessario rifattorizzare il secondo argomento.
Successivamente, per ogni fattore \(\mathcal{Q}_i\) del secondo argomento si
individua il fattore corrispondente \(\mathcal{P}'_k\) in \(\mathcal{P}'\) e si
procede a individuare l'insieme \(\mathcal{C}_{\mathcal{O}_i}\) di vincoli di
\(\mathcal{Q}_i\) che sono \emph{stabili} rispetto a \(\mathcal{P}'_k\): questi vincoli
costituiscono il risultato del widening rispetto a quel fattore. È possibile,
come caso speciale, che se \(\pi_{\mathcal{P}'_k} = \pi_{\mathcal{Q}_i}\), allora è
possibile applicare direttamente l'operatore di widening per poliedri non
fattorizzati.

\begin{algorithm}[H]
\caption{Meet}\label{meet}
\begin{algorithmic}[1]
\Function{Widenind}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{Q}, \pi_{\mathcal{Q}}$}
\State $\overline{\pi}$ := $\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}$
\State $\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \overline{\pi}$}
\State $\mathcal{O}$ := $\emptyset$
\For{\textbf{each} $i$ \textbf{in} $\{1,...,r\}$}\Comment{$q$ = numero di blocchi in $\pi_{\mathcal{Q}}$}
\State $\mathcal{C}_{\mathcal{O}_i}$ := $\emptyset$
\State $k$ := $j$, t.c. $\mathcal{X}_{\mathcal{Q}_i} \subseteq \mathcal{X}_j, \mathcal{X}_j \in \overline{\pi}$
\If{$\overline{\pi}_k = \overline{\pi}_{\mathcal{Q}_i}$}
\State $\mathcal{Q}_i$ := \Call{Widening}{$\mathcal{P}'_k, \mathcal{Q}_i$}
\Else
\State $\mathcal{C}_{\mathcal{O}_i}$ := \Call{select\_stable\_con}{$\mathcal{C}_{\mathcal{Q}_i}, \mathcal{P}'_k$}
\State $\mathcal{Q}_i$ := \Call{new\_factor}{$\mathcal{C}_{\mathcal{O}_i}$}
\EndIf
\State $\mathcal{O}$.add$(\mathcal{O}_i)$
\EndFor
\State\Return $\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}



\chapter{Implementazione}
\label{sec:org36c49dd}
Questo capitolo tratterà dell'implementazione effettiva dei poliedri
fattorizzati e di alcune loro operazioni. La struttura è stata basata su di un
\emph{wrapper} preesistente nella \emph{PPlite} mentre alcune delle implementazioni sono
state attuate effettuando un porting dalla libreria \emph{PPL}. La maggiorparte delle
operazioni sono state sviluppate come un wrapper per la \emph{PPLite}, difatti le
operazioni sui singoli poliedri sono gestite da essa. Lo scopo principale è
quello di inserirsi all'interno dell'analisi statica e utilizzare i poliedri
fattorizzati se e quando vengono generati poliedri che implicano un alto
overhead per essere gestiti, in questo caso i suddetti poliedri vengono
fattorizzati in maniera tale da diminuire il carico computazionale.
L'implementazione è stata sviluppata interamente in \emph{C++11} con l'obiettivo di
utilizzare i metodi della \emph{Standard Library} così da incrementare la leggibilità
del codice. L'efficienza non è stata presa come obiettivo principale durante lo
sviluppo, dando importanza alla correttezza e alla leggibilità del codice.

\section{\texttt{F\_Poly}}
\label{sec:org3e1a123}
La classe dove sono compresi gran parte dei medoti è \texttt{F\_Poly}. È stata
definita nel file \texttt{F\_Poly.hh} dove sono presenti 92 metodi pubblici e 14 metodi
privati.

Per la costruzione/distruzione degli oggetti è stata seguita la
\emph{Rule of Five}, quindi abbiamo:

\begin{itemize}
\item Un costruttore esplicito, un costruttore per copia, un costruttore per spostamento
\item Operazioni di assegnamento per copia e per spostamento;
\item Un distruttore;
\end{itemize}

Abbiamo anche:

\begin{itemize}
\item Un metodo \texttt{check\_inv()} per controllare che le invarianti di classe non siano
state violate;
\item Le operazioni principali descritte nel Capitolo 2.3;
\item Funzioni di appoggio per gestire il poliedro;
\end{itemize}

Sono inoltre presenti delle stutture dati per la gestione dei fattori:

\begin{itemize}
\item \texttt{Block}: un \texttt{std::vector}\footnote{\texttt{template<class T, class Allocator = std::allocator<T>> class vector;}} di \texttt{dim\_type} che rappresenta un blocco \(\mathcal{X}_i\) che
contiene alcune dimensioni del poliedro;
\item \texttt{Blocks}: un \texttt{std::vector} di \texttt{Block} che esprime le partizioni del poliedro;
\item \texttt{Factor}: un fattore è un poliedro, difatti \texttt{Factor} è un alias per oggetti di tipo \texttt{Poly};
\item \texttt{Factors}: un \texttt{std::vector} di \texttt{Factor};
\end{itemize}

Sono inoltre presenti tre variabili:

\begin{itemize}
\item \texttt{dim\_type dim}: indicante le dimensioni del poliedro
\item \texttt{Topol topol}: indicante la topologia del poliedro
\item \texttt{bool is\_empty}: indicante se il poliedro è vuoto o no
\end{itemize}

\subsection{\texttt{check\_inv()}}
\label{sec:orgbc2d239}
Il metodo menzionato contiene tutti i controlli necessari per verificare che
l'invariante di classe non sia stata violata, e che quindi il poliedro su cui si
sta lavorando è in condizioni di correttezza. Le invarianti di classe che devono
essere rispettate sono le seguenti:

\begin{itemize}
\item La dimensione minima del poliedro deve essere \(\ge 0\)
\begin{minted}[,fontsize=\small]{c++}
if (dim < 0) {
  reason = "F_Poly broken: invalid space dimension";
  maybe_dump();
  return false;
}
\end{minted}
\item Se il poliedro è vuoto, i fattori e i blocchi devono essere anch'essi vuoti
\begin{minted}[,fontsize=\small]{c++}
if (is_empty()) {
  if (!(factors.empty() && blocks.empty())) {
    reason = "F_Poly broken: empty polyhedron has factors";
    maybe_dump();
    return false;
  }
  // No other check for an empty polyhedron.
  return true;
}
\end{minted}
\item Il numero di blocchi deve essere uguale al numero di fattori
\begin{minted}[,fontsize=\small]{c++}
if (factors.size() != blocks.size()) {
  reason = "F_Poly broken: #factors != #blocks";
  maybe_dump();
  return false;
}
\end{minted}
\item La cardinalità dei blocchi deve essere uguale a \texttt{dim}
\begin{minted}[,fontsize=\small]{c++}
dim_type dim_ = 0;
for (const auto& block : blocks)
  dim_ += block.size();
if (dim != dim_) {
  reason = "F_Poly broken: space dimension mismatch";
  maybe_dump();
  return false;
}
\end{minted}
\item Le dimensioni di un fattore devono essere uguali alle dimensioni del blocco
che lo rappresenta
\begin{minted}[,fontsize=\small]{c++}
// Each factor space dim should match its block.
for (dim_type i = 0; i < num_rows(factors); ++i)
  if (factors[i].space_dim() != num_rows(blocks[i])) {
    reason = "F_Poly broken: factor vs block space dim mismatch";
    maybe_dump();
    return false;
  }
\end{minted}
\item Nessun fattore deve essere vuoto
\begin{minted}[,fontsize=\small]{c++}
if (std::any_of(factors.begin(), factors.end(),
                std::mem_fn(&Poly::is_empty))) {
  reason = "F_Poly broken: empty factor";
  maybe_dump();
  return false;
}
\end{minted}
\item Ogni dimensione dello spazio deve apparire una e una volta soltanto nei
blocchi e non devono esserci blocchi vuoti
\begin{minted}[,fontsize=\small]{c++}
std::vector<bool> dims(dim, false);
for (const auto& block : blocks) {
  if (block.size() == 0) {
    reason = "F_Poly broken: found empty block";
    maybe_dump();
    return false;
  }
  for (const auto d : block) {
    if (d < 0 || d >= dim) {
      reason = "F_Poly broken: block contains an illegal
                space dim";
      maybe_dump();
      return false;
    }
    if (dims[d]) {
      reason = "F_Poly broken: repeated space dim in blocks";
      maybe_dump();
      return false;
    }
    dims[d] = true;
  }
}
\end{minted}
\item Ogni dimensione dello spazio deve essere presente in un blocco
\begin{minted}[,fontsize=\small]{c++}
if (std::find(dims.begin(), dims.end(), false) != dims.end()) {
  reason = "F_Poly broken: a space dim is missing from blocks";
  maybe_dump();
  return false;
}
\end{minted}
\end{itemize}

\section{Operazione di base}
\label{sec:orgb9c01da}
Durante la lettura di questo paragrafo, sarà palese la diversa notazione
utilizzata rispetto a \cite{fastpoly}: questo perché, per motivi di
compatibilità e trasparenza si è deciso di implementare le varie operazioni
utilizzando i nomi con il loro corrispettivo della \emph{PPLite}.

Inizialmente il lavoro si è basato sul attuare un porting dai poliedri
fattorizzati implementati nella \emph{PPL}, successivamente il focus è stato
nell'adattarli al meglio alle strutture utilizzate nella PPLite, permettendo una
semplificazione nella codifica e nel testing. Il principio base
sotto all'implementazione di alcune operazioni è stato quello di preparare
strutturalmente i poliedri fattorizzati in maniera tale da rendere possibile
richiamare le varie operazioni.

Diverse sono le funzioni più significative definite all'interno di \texttt{F\_Poly.hh}:

\begin{minted}[,fontsize=\small]{c++}
static Factors refactor(const Factors& f,
                        const Blocks& b1, const Blocks& b2);
static Blocks least_upper_bound(const Blocks& b1, const Blocks& b2);
static Blocks merge(const Blocks& b, const Block& added);
void join(const Factors& f, const Blocks& b);
void join(const F_Poly& f);
void affine_image(Var var, const Linear_Expr& expr,
                  const Integer& inhomo = Integer::zero(),
                  const Integer& den = Integer::one());


void affine_preimage(Var var, const Linear_Expr& expr,
                     const Integer& inhomo = Integer::zero(),
                     const Integer& den = Integer::one());
void add_con(const Con& c);
void add_gen(const Gen& c);
bool inclusion(const Factors& f, const Blocks& b) const;
\end{minted}

\subsection{\texttt{refactor}}
\label{sec:org3656f4e}
La semantica rimane invariata invariata rispetto a quanto descritto
nell'Algoritmo \ref{refactor}. Per la \emph{join} \((\bowtie)\) tra i fattori è stata
utilizzata la \texttt{concatenate\_assign()} della PPlite, una funzione omonima, per
quanto riguarda il join dei blocchi, è stata implementata utilizzando \texttt{std::insert}\footnote{\texttt{template <class InputIt>
iterator insert(const\_iterator pos, InputIt first, InputIt last);}}
\chapter{Conclusione}
\label{sec:org9902a33}

\bibliographystyle{plain}
\renewcommand\bibname{Bibliografia}
\bibliography{mybib}
\end{document}

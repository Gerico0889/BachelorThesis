% Created 2019-03-05 mar 17:43
% Intended LaTeX compiler: pdflatex
\documentclass{mimosis}
 \usepackage{listings}
\usepackage{minted}
 \addto\captionsenglish{\renewcommand\contentsname{Indice}}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{float}
\usepackage[noend]{algpseudocode}
\KOMAoptions{fontsize=12pt,headings=normal,twoside=false,headsepline=true,footsepline=false}
\makeglossaries
\theoremstyle{definition}
\newtheorem{exmp}{Esempio}[section]
\usepackage{amsmath}
\floatname{algorithm}{Algoritmo}
\usepackage{amsfonts}
\usepackage{amssymb}
\let\emptyset\varnothing
\usepackage{bm}
\usepackage{listings}
\usepackage{color}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{backcolour}{RGB}{247,248,250}
\definecolor{codebrown}{RGB}{171,88,106}
\definecolor{codeblue}{RGB}{122,99,192}
\definecolor{codeorange}{RGB}{255,165,121}
\lstdefinestyle{mystyle}{
language=C++,
backgroundcolor=\color{backcolour},
commentstyle=\color{codegreen},
keywordstyle=\color{codeblue},
keywordstyle=[2]{\color{codeblue}},
morekeywords={Blocks, Block, Factor, Factors, dim_type,
Vars, Index_Set, Linear_Expr, Con, Cons, Gen,
Gens, Var, F_Poly},
numberstyle=\tiny\color{codegray},
stringstyle=\color{codeorange},
basicstyle=\footnotesize\ttfamily,
breakatwhitespace=false,
breaklines=true,
captionpos=b,
keepspaces=true,
numbers=none,
showspaces=false,
showstringspaces=false,
showtabs=false,
tabsize=2
}
\usepackage{unipr}
\titolo{Fattorizzazione cartesiana \\ nella libreria PPLite}
\titoloIng{Cartesian Factoring in the PPLite Library}
\laureando{Luigi Zaccone}
\annoaccademico{2017-2018}
\corsodilaurea{Informatica}
\relatore[Prof.]{Enea Zaffanella}

\newcommand{\mboxparagraph}[1]{\paragraph{#1}\mbox{}\\}
\newcommand{\mboxsubparagraph}[1]{\subparagraph{#1}\mbox{}\\}
\author{KernelPanic}
\date{\today}
\title{a}
\hypersetup{
 pdfauthor={KernelPanic},
 pdftitle={a},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.1 (Org mode 9.1.14)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\chapter{Introduzione}
\label{sec:orgbeab7bd}

\chapter{Fattorizzazione cartesiana}
\label{sec:orge4d63ca}
I poliedri chiusi convessi che saranno utilizzati potranno essere rappresentati
in due modi:

\begin{itemize}
\item tramite un sistema finito di vincoli \(\mathcal{C}\). I vincoli
non sono altro che le equazioni e disequazioni che individuano rispettivamente
gli iperpiani e i semispazi del poliedro \cite{Becchi17th};
\item tramite un sistema finito di generatori \(\mathcal{G}\). Questi
permettono di costruire il luogo geometrico dei punti determinati da
combinazioni di particolari elementi del poliedro stesso \cite{Becchi17th}. I
generatori possono essere formati da:
\begin{itemize}
\item \textbf{punto}: ogni elementi del poliedro \(\mathcal{P}\) è un suo punto. Un punto
può anche essere un \emph{vertice} se non può essere espresso come combinazione
convessa di altri punti in \(\mathcal{P}\);
\item \textbf{raggio}: un raggio di un poliedro non vuoto \(\mathcal{P}\) è un vettore
\(\bm{r} \in \mathbb{R}^n\) non nullo tale che per ogni \(\bm{x} \in
    \mathcal{P}\) e per ogni \(\mu \ge 0\) vale
\begin{align*}
(\bm{x} + \mu \bm{r}) \in \mathcal{P}
\end{align*}
se \(\mathcal{P} = \emptyset\) allora non ha raggi.

Un raggio quindi definisce una direzione dove il poliedro è illimitato.
\item \textbf{retta}: un vettore \(\bm{l} \in \mathbb{R}^n\) è una retta di un poliedro non
vuoto \(\mathcal{P}\) se e solo se i vettori \(\bm{l}\) e -\(\bm{l}\) sono
entrambi raggi del poliedro \(\mathcal{P}\). Vale quindi che per ogni \(\bm{x}
    \in \mathcal{P}, \mu \in \mathbb{R}\)
\begin{align*}
(\bm{x} + \mu\bm{l}) \in \mathcal{P}
\end{align*}
Se \(\mathcal{P} = \emptyset\) allora non ha rette.

Quindi possiamo esprimere un generatore come \(\mathcal{G} =
    (\mathit{L},\mathit{R},\mathit{P})\) dove \(\mathit{L},\mathit{R},\mathit{P}\)
sono sottoinsiemi finiti di \(\mathbb{R}^n\) di cardinalità \(l,r\) e \(p\)
rispettivamente, tali che \(\bm{0} \notin \mathit{R}\) e \(\bm{0} \notin \mathit{L}\), con
\begin{align*}
\mathcal{P} = \text{gen}(\mathcal{G}) \stackrel{\text{def}}{=} \{\mathit{L}\bm{\lambda} + \mathit{R}\bm{\rho} + \mathit{P}\bm{\pi} \: | \:
\bm{\lambda} \in \mathbb{R}^l, \bm{\rho} \in \mathbb{R}^r_+, \bm{\pi} \in \mathbb{R}^p_+, \sum\limits_{i=1}^p \pi_i = 1\}
\end{align*}

I punti di un poliedro \(\mathcal{P}\) sono quindi ottenibili come somma di combinazioni
convesse dei punti in \(\mathit{P}\) e di combinazioni non negative
dei raggi in \(\mathit{R}\) (e quindi combinazioni lineari delle rette in \(\mathit{L}\)).
\end{itemize}
\end{itemize}

La fattorizzazione cartesiana, quando applicata, permette di diminuire la complessità di esecuzione
delle operazioni sui poliedri convessi. L'idea è che i poliedri
utilizzati nell'analisi dei programmi non mettono in relazione tutte le
variabili del programma in un solo vincolo. Per esempio: un ipercubo \\
\(H_n = \{0 \le x_i \le 1 \; | \; i = 1,...,n\}\)
richiede \(2^n\) generatori di \(n\) dimensioni per essere rappresentato, tramite la decomposizione
invece ne sono necessari solo \(2n\) di dimensione 1. La terminologia e gli esempi saranno
ispirati al lavoro svolto in \cite{fastpoly}.

\section{Blocchi e fattori}
\label{sec:orgaa3994d}
Qui e nei successivi paragrafi verrano considerati esclusivamente poliedri \emph{non}
vuoti.

Sia \(\mathcal{X} = \{x_1, x_2,..., x_n\}\) un insieme di \(n\) variabili. Dato un poliedro, \(\mathcal{X}\)
può essere partizionato in un sottoinsieme \(\mathcal{X}_k\) che chiamiamo \emph{blocco} tale
che i vincoli esistono solo tra variabili presenti nello stesso \emph{blocco}.
Quindi, ogni variabile priva di vincoli risiede in un singoletto. Ci riferiamo a
questo insieme come \(\pi = \pi_P = \{\mathcal{X}_1, \mathcal{X}_2,..., \mathcal{X}_t\}\).

\begin{exmp}
Consideriamo
\begin{align*}
  &\mathcal{X} = \{x_1, x_2, x_3\} ~{}e \\
  &P = \{x_1 + 2x_2 \le 3\}.
\end{align*}

In questo caso $\mathcal{X}$ viene partizionato in due blocchi: $\mathcal{X}_1 = \{x_1, x_2\}$ e
$\mathcal{X}_2 = \{x_3\}$.
\end{exmp}

Per ogni blocco, quindi, sarà presente un \emph{fattore} \(P_k\) che sarà composto solo
dalle variabili presenti nel suo blocco. In qualsiasi momento il poliedro
originale può essere recuperato "concatenando" i fattori, che equivale ad
applicare l'unione dei sistemi di vincoli
\(\mathcal{C}_{P_k}\) e una variante del prodotto cartesiano (in quanto viene
applicato solo ai punti e non alle linee o ai raggi) dei generatori \(\mathcal{G}_{P_k}\).

\begin{exmp}
  Consideriamo un poliedro $\mathcal{P}$ con i seguenti vincoli e generatori:
  \begin{align*}
    &\mathcal{C} = \{-x_{1} \le -1, x_{1} \le 4, -x_{2} \le -2, x_{2} \le 4\} \\
    &\mathcal{G} = \{\mathit{L}, \mathit{R}, (1,2)^T, (1,4)^T, (4,2)^T, (4,4)^T\} \\
    &\text{Con } \mathit{L} \text{ insieme delle rette e } \mathit{R} \text{ insieme dei raggi.}
  \end{align*}

  Il poliedro non ha vincoli tra le variabili $x_1$ e $x_2$. Quindi, $\mathcal{X} = \{x_1,x_2\}$
  può essere partizionato nei blocchi: $\pi_P = \{\{x_1\}, \{x_2\}\}$ con i risultanti fattori
  $P_1 = (\mathcal{C}_{P_1}, \mathcal{G}_{P_1})$ e $P_2 = (\mathcal{C}_{P_2}, \mathcal{G}_{P_2})$ dove:
  \begin{align*}
      &\mathcal{C}_{P_{1}} = \{-x_{1} \le -1, x_{1} \le 4\}  &&\mathcal{C}_{P_{2}} = \{ -x_{2} \le -2, x_{2} \le 4\} \\
      &\mathcal{G}_{P_{1}} = \{\mathit{L}, \mathit{R}, (1,4)^T\} &&\mathcal{G}_{P_{2}} = \{\mathit{L}, \mathit{R}, (2,4)^T\}
  \end{align*}
  Il poliedro originale può essere ricavato da $P_{1}$ e $P_{2}$ come
  P = $P_{1} \bowtie P_{2} = (\mathcal{C}_{P_{1}} \cup \mathcal{C}_{P_{2}}, \mathcal{G}_{P_{1}} \times \mathcal{G}_{P_{2}})$
\end{exmp}

L'insieme \(\mathcal{L}\) che consiste in tutte le partizioni possibili di \(\mathcal{X}\)
forma un \emph{reticolo di partizioni} \((\mathcal{L}, \sqsubseteq, \sqcup, \sqcap,
\bot, \top)\). Gli elementi \(\pi\) del reticolo sono ordinati come segue: \(\pi
\sqsubseteq \pi'\), se ogni blocco di \(\pi\) è incluso in qualche blocco di
\(\pi'\), si dice quindi che \(\pi\) è "più fine" di \(\pi\)\^{}' o, equivalentemente che
\(\pi\)\^{}' è più "grossolana" di \(\pi\). Questo reticolo è dotato degli operatori di \emph{least upper bound}
\((\sqcup)\) che permette di calcolare, dati due blocchi, la partizione più
raffinata e \emph{greatest upper bound} \((\sqcap)\) che permette di calcolarne quella
più grossolana. È da notare che nel reticolo della
partizione \(\top = \{\mathcal{X}\}\) e \(\bot = \{\{x_1\}, \{x_2\}, ..., \{x_n\}\}\).

\section{Partizione ammissibile}
\label{sec:org1754786}
Una partizione \(\pi\) è \emph{ammissibile} per un poliedro P se non esistono
variabili \(x_i\) e \(x_j\) in diversi blocchi di \(\pi\) relazionati da un vincolo di
P, ovvero \(\pi \sqsupseteq \pi_P\). Le partizioni ammissibili sono un
sottoinsieme chiuso superiormente del reticolo, chiameremo questo sottoinsieme
\(\mathcal{B}\). Se \(\pi \in \mathcal{B}\) allora lo saranno anche tutte
le \(\pi'\) tali che \(\pi, \pi' \in \mathcal{L}\) e
\(\pi \sqsubseteq \pi'\). Le partizioni ammissibili sono
dotate di elemento minimo ovvero la più fine partizione appartenente a
\(\mathcal{B}\), partizione che verrà anche considerata come la migliore. Questa
partizione minima viene calcolata come spiegato nell'\textbf{esempio 2.1.1}.

Il nostro obiettivo è quello di cercare di utilizzare sempre la partizione
ammissibile minima.
\section{Operazioni}
\label{sec:org85912c1}
In questo paragrafo verrà spiegato l'effetto che alcune operazioni dei poliedri
generano sui fattori. Occorre premettere che in quasi tutte le operazioni
binarie, i poliedri hanno la stessa dimensione. Fa eccezione la concatenazione. Per descrivere
meglio queste operazioni, è necessario prima dare una specifica di alcune
funzioni utilizzate all'interno delle prime.
\(\\\)
\(\\\)
\-\hspace{0.1cm} \textbf{Convert Constraint.} Funzione che mappa le dimensioni di un vincolo o
generatore all'interno di un fattore. La PPLite utilizza dimensioni nel range
\([0, ..., n]\) per i poliedri. Tramite la fattorizzazione è quindi necessario
tradurre gli indici esterni a quelli interni dei vari blocchi.
\(\\\)
\(\\\)
\-\hspace{0.1cm} \textbf{Least Upper Bound.} Questa funzione estrae il \emph{lub} di due partizioni.
Dall'Algoritmo 1 si può notare come sia necessario generare l'insieme delle
unioni dei due blocchi \(\pi_{\mathcal{P}}\) e \(\pi_{\mathcal{Q}}\) in
\(\pi\). Successivamente si uniscono tra loro tutti i blocchi di
\(\pi\) che hanno un'intersezione non vuota, calcolando
successivamente la partizione corretta.
\begin{algorithm}[H]
  \caption{Least-Upper-Bound}\label{lub}
  \begin{algorithmic}[1]
    \Function{Least-Upper-Bound}{$\pi_{\mathcal{P}}, \pi_{\mathcal{Q}}$}
    \State $\pi := \emptyset$
    \For{\textbf{each} $\mathcal{X}_{\mathcal{P}i}$ \textbf{in} $\pi_{\mathcal{P}}$}
    \State$\mathcal{B}$:= $\emptyset$
    \For{\textbf{each} $\mathcal{X}_{\mathcal{Q}k}$ \textbf{in} $\pi_{\mathcal{Q}}$}
    \If{$\mathcal{X}_{\mathcal{P}i} \cap\mathcal{X}_{\mathcal{Q}k} \ne \emptyset$}
    \State$\mathcal{B}:=\mathcal{B} \cup\mathcal{X}_{\mathcal{Q}k}$
    \EndIf
    \EndFor
    \State $\pi$.add($\mathcal{B}$)
    \EndFor
    \While{$\exists$ $\mathcal{X}_i, \mathcal{X}_j \in \pi$, $i \ne j$ \textbf{t.c.} $\mathcal{X}_i \cap \mathcal{X}_j \ne \emptyset$}
    \State $\pi$ := $(\pi \setminus \{\mathcal{X}_i, \mathcal{X}_j\}) \cup \{\mathcal{X}_i \cup \mathcal{X}_j\}$
    \EndWhile
    \Return $\pi$
    \EndFunction
  \end{algorithmic}
\end{algorithm}
\(\\\)
\(\\\)
\-\hspace{0.1cm} \textbf{Merge.} Definito come \(\uparrow\), quando si ha l'operazione
\(\pi \uparrow \mathcal{A}\), dove \(\pi\) è una partizione di un poliedro e
\(\mathcal{A}\) è un sottoinsieme delle sue variabili (non per forza connesse da
vincoli), genera una partizione \(\pi_{m}\) tale che:
\begin{itemize}
\item \(\exists\) \(\mathcal{X}_i \in \pi_m : \mathcal{A} \subseteq \mathcal{X}_i\), \(\pi \sqsubseteq \pi_{m}\)
\end{itemize}
Viene quindi generata una nuova fattorizzazione unendo i blocchi del poliedro
che hanno variabili in comune con \(\mathcal{A}\). Questa unione genera un blocco
unico \(\mathcal{D}\), tale che \(\mathcal{A} \subseteq \mathcal{B}\).

\begin{algorithm}[H]
\caption{Merge}\label{merge}
\begin{algorithmic}[1]
\Function{Merge}{$\pi, \mathcal{A}$}
\State$\pi_m := \emptyset$
\State$\mathcal{B} := \emptyset$
\For{\textbf{each} $\mathcal{X}_{i}$ \textbf{in} $\pi$}
\If{$\mathcal{X}_{i} \cap \mathcal{A} \ne \emptyset$}
\State$\mathcal{B} := \mathcal{B} \cup \mathcal{X}_{i}$
\Else
\State$\pi_m$.add$(\mathcal{X}_{i})$
\EndIf
\EndFor
\State$\pi_m$.add$(\mathcal{B})$
\State\textbf{return} $\pi_m$
\EndFunction
\end{algorithmic}
\end{algorithm}

\-\hspace{0.1cm} \textbf{Refactor.} Questa operazione ha come argomenti un poliedro
fattorizzato e una fattorizzazione ammissibile \(\pi\) per questo
poliedro. Non fa altro che convertire i fattori rispetto alla seconda
fattorizzazione. È importante notare che la partizione ammissibile non sarà più
fine di \(\pi_{\mathcal{P}}\), visto che i blocchi non vengono divisi bensì solo
uniti.

La refactor è un'operazione necessaria in quanto, avendo due poliedri
\(\mathcal{P}\) e \(\mathcal{Q}\) definiti sullo stesso insieme di variabili \(X =
\{x_1, x_2, ..., x_n\}\) e presi \(\pi_{\mathcal{P}} =
\{X_{\mathcal{P}_1}, X_{\mathcal{P}_2}, ..., X_{\mathcal{P}_r}\}\),
\(\pi_{\mathcal{Q}} = \{X_{\mathcal{Q}_1}, X_{\mathcal{Q}_2}, ...,
X_{\mathcal{Q}_s}\}\)
partizioni corrette di \(\mathcal{P}\) e \(\mathcal{Q}\) in genere abbiamo che
\(\pi_{\mathcal{P}} \ne \pi_{\mathcal{Q}}\). È necessario
che, come in molte operazioni comuni nell'analisi e manipolazione dei poliedri,
le dimensioni delle partizioni utilizzate siano uguali in quantità e valori. Se
si applica la fattorizzazione su poliedri aventi gli stessi blocchi non si fa
altro che calcolare il \emph{lub} (\(\pi = \pi_{\mathcal{P}}
\; \sqcup \; \pi_{\mathcal{Q}}\)).

\begin{algorithm}[H]
\caption{Refactor}\label{refactor}
\begin{algorithmic}[1]
\Function{Refactor}{$\mathcal{P}, \pi, \pi_{\mathcal{P}}$}
\State$\mathcal{O}, \pi_{\mathcal{O}} := \emptyset$
\For{\textbf{each} $i$ \textbf{in} $\{1,..., r\}$} \Comment{r = numero blocchi di $\pi$}
\State$\mathcal{O}_{i}, \pi_{\mathcal{O}i} := \emptyset$
\For{\textbf{each} $j$ \textbf{in} $\{1,...,m\}$} \Comment{m = numero blocchi di $\pi_{\mathcal{P}}$}
\If{$\pi_{\mathcal{P}i} \cap \pi_{j} \ne \emptyset$}
\State$\mathcal{O}_{i}$ := $\mathcal{O}_{j} \bowtie \mathcal{P}_{i}$
\State$\pi_{\mathcal{O}i}$ := $\pi_{\mathcal{O}i} \bowtie \pi_{\mathcal{P}i}$
\EndIf
\EndFor
\State$\mathcal{O}$.add$(\mathcal{O}_{i})$
\State$\pi_{\mathcal{O}}$.add$(\pi_{\mathcal{O}i})$
\EndFor
\State\Call{Remap-Dimensions}{$\mathcal{O}, \pi_{\mathcal{O}}, \pi$}
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

Come spiegato precedentemente, la refactor prende in input un poliedro
fattorizzato \(\mathcal{P}\) e la sua partizione \(\pi\) per
rifattorizzarlo in base al terzo parametro \(\pi_{\mathcal{P}}\). Non fa altro che
unire i fattori che hanno intersezione dei relativi blocchi non vuota tra
\(\pi_{\mathcal{P}}\) e \(\pi\) e generare il blocco finale. È importante
ri-mappare le dimensioni dei fattori di output in base a quelle descritte nel
blocco di \(\pi_{\mathcal{P}}\).

\subsection{Inclusion Test (\(\sqsubseteq\))}
\label{sec:org7d0175a}
Operazione necessaria per controllare se un poliedro è incluso in un altro.
Disponendo di una doppia rappresentazione è possibile controllarlo se, dati due
poliedri \(\mathcal{P}\) e \(\mathcal{Q}\), tutti i generatori in
\(\mathcal{G}_{\mathcal{P}}\) soddisfano tutti i vincoli in
\(\mathcal{C}_{\mathcal{Q}}\).

Nel nostro caso, come mostrato nell'Algoritmo 4, è stata implementata tramite
wrapper. In particolare vengono rifattorizzati i poliedri con il \emph{lub}
\(\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}\) e successivamente viene applicata
l'\emph{inclusion} in ordine su ogni coppia di fattori: il test avrà successo se
tutti i test ritornano \emph{True}.

\begin{algorithm}[H]
\caption{Inclusion Test}\label{inclusion test}
\begin{algorithmic}[1]
\Function{Inclusion}{$\mathcal{P},\pi_{\mathcal{P}},\mathcal{Q},\pi_{\mathcal{Q}}$}
\State$\pi$ := \Call{Least-Upper-Bound}{$\pi_{\mathcal{P}},\pi_{\mathcal{Q}}$}
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \pi$}
\State$\mathcal{Q}'$ := \Call{Refactor}{$\mathcal{Q}, \pi_{\mathcal{Q}}, \pi$}
\For{\textbf{each} $k$ \textbf{in} $\{1,...,r\}$} \Comment{r = numero di blocchi in $\pi$}
\If{$\mathcal{P}'_{k}$ non include $\mathcal{Q}'_{k}$ }
\State\Return\textit{False}
\EndIf
\EndFor
\State\Return\textit{True}
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Join (\(\sqcup\))}
\label{sec:orgfdef7a7}
Tramite la doppia rappresentazione, i generatori \(\mathcal{G}_{\mathcal{O}}\)
dove \(\mathcal{O}\) è il risultato del \emph{join}, sono semplicemente l'unione dei
generatori dei poliedri presi in input dalla funzione, ovvero
\(\mathcal{G}_{\mathcal{O}}\) = \(\mathcal{G}_{\mathcal{P}} \cup
\mathcal{G}_{\mathcal{Q}}\). I vincoli \(\mathcal{C}_{\mathcal{O}}\) sono ottenuti
aggiungendo incrementalmente i generatori di \(\mathcal{G}_{\mathcal{Q}}\) al
poliedro definito da \(\mathcal{C}_{\mathcal{P}}\).

\begin{algorithm}[H]
\caption{Join}\label{join}
\begin{algorithmic}[1]
\Function{Join}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{O}, \pi_{\mathcal{O}}$}
\If{\Call{is\_empty}{$\mathcal{P}$}}
\State$\mathcal{O}, \pi_{\mathcal{O}}$ := $\mathcal{Q}, \pi_{\mathcal{Q}}$
\ElsIf{\Call{is\_empty}{$\mathcal{Q}$}}
\State$\mathcal{O}, \pi_{\mathcal{O}}$ := $\mathcal{P}, \pi_{\mathcal{P}}$
\Else
\State$\mathcal{O}, \pi_{\mathcal{O}}$ := \Call{Join-Poly}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{O}, \pi_{\mathcal{O}}$}
\EndIf
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

Avendo un sistema di poliedri fattorizzati, è necessario per prima cosa
rifattorizzare \(\mathcal{P}\) e \(\mathcal{Q}\) utilizzando il loro \emph{lub}. Per ogni
coppia di fattori \((\mathcal{P}'_{i}, \mathcal{Q}'_{i})\) uguali, se ne aggiunge
uno con il rispettivo blocco \(\pi_i\) al risultato. Se invece i due
fattori risultano diversi, ognuno viene unita a una coppia di fattori comuni
\((\mathcal{P}_{\mathcal{T}}, \mathcal{Q}_{\mathcal{T}})\) e successivamente si calcola la \emph{join} di
questi due fattori e si inserisce insieme al rispettivo blocco nel poliedro di
output.

Un caso speciale è stato assegnato ai poliedri \emph{vuoti}. Dati \(\mathcal{P}\) come
poliedro \emph{vuoto} e \(\mathcal{Q}\) un poliedro generico allora \(\mathcal{Q} \sqcup
\mathcal{P}\) = \(\mathcal{Q}\) e anche \(\mathcal{P} \sqcup
\mathcal{Q}\) = \(\mathcal{Q}\).

Se invece \(\pi = \pi_{\mathcal{P}} \sqcup
\pi_{\mathcal{Q}}\) e \(\mathcal{U} = \{\mathcal{X}_k \: | \: \mathcal{P}
= \mathcal{Q}, \mathcal{X}_k \in \pi \}\) allora la partizione
ammissibile, in questo caso, sarà uguale a:

\begin{align*}
\pi_{\mathcal{P} \sqcup \mathcal{Q}} = \mathcal{U} \cup \bigcup_{\mathcal{T} \in \pi \backslash \mathcal{U}} \mathcal{T}
\end{align*}

\begin{algorithm}[H]
\caption{Join-Poly}\label{join-poly}
\begin{algorithmic}[1]
\Function{Join-Poly}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{O}, \pi_{\mathcal{O}}$}
\State$\pi$ := $\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}$
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P, \pi_{\mathcal{P}}, \pi}$}
\State$\mathcal{Q}'$ := \Call{Refactor}{$\mathcal{Q, \pi_{\mathcal{Q}}, \pi}$}
\For{\textbf{each} $i$ \textbf{in} $\{0,...,|\mathcal{P}'|\}$}
\If{$\mathcal{P}'_i = \mathcal{Q}'_i$}
\State$\mathcal{O}$.add$(\mathcal{P}'_{i})$
\State$\pi_{\mathcal{O}}$.add$(\mathcal{X}'_{i})$
\Else
\State$\mathcal{X}_{\mathcal{T}}$ := $\mathcal{X}_{\mathcal{T}} \cup \mathcal{X}_i$
\State$\mathcal{P}_{\mathcal{T}}$ := $\mathcal{P}_{\mathcal{T}} \bowtie \mathcal{P}'_{i}$
\State$\mathcal{Q}_{\mathcal{T}}$ := $\mathcal{Q}_{\mathcal{T}} \bowtie \mathcal{Q}'_{i}$
\EndIf
\EndFor
\State$\mathcal{P}_{\mathcal{T}}$ := $\mathcal{P}_{\mathcal{T}} \sqcup \mathcal{Q}_{\mathcal{T}}$
\State$\pi_{\mathcal{O}}$.add$(\mathcal{X}_{\mathcal{T}})$
\State$\mathcal{O}$.add$(\mathcal{P}_{\mathcal{T}})$
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Meet (\(\sqcap\))}
\label{sec:orgdba80a7}
Per la doppia rappresentazione, \(\mathcal{P} \sqcap \mathcal{Q}\) genera un
poliedro i cui vincoli \(\mathcal{C}_{\mathcal{P} \sqcap \mathcal{Q}}\) sono
risultati dall'unione di \(\mathcal{C}_{\mathcal{P}}\) e
\(\mathcal{C}_{\mathcal{Q}}\), mentre \(\mathcal{G}_{\mathcal{P} \sqcap
\mathcal{Q}}\) si ottiene aggiungendo incrementalmente i vincoli di
\(\mathcal{C}_{\mathcal{Q}}\) al poliedro \(\mathcal{P}\). Se \(\mathcal{P} \sqcap
\mathcal{Q}\) risulta non soddisfacibile allora \(\mathcal{P} \sqcap \mathcal{Q} =
\bot\) e \(\mathcal{G}_{\mathcal{P} \sqcap \mathcal{Q}} = \emptyset\).

Per quanto riguarda i poliedri fattorizzati è necessario generare
\(\pi = \pi_{\mathcal{P}} \sqcup
\pi_{\mathcal{Q}}\) e rifattorizzare i due poliedri \(\mathcal{P}\) e
\(\mathcal{Q}\) tramite essa, generando quindi \(\mathcal{P}'\) e \(\mathcal{Q}'\).
Per tutte le \(r\) coppie di fattori \(\mathcal{P}'_i\) e \(\mathcal{Q}'_i\), se
sono uguali aggiungo \(\mathcal{P}'_i\) con il rispettivo blocco al poliedro di
output \(\mathcal{O}\), altrimenti creo un fattore \(\mathcal{F} = \mathcal{P}'_i
\sqcap \mathcal{Q}'_i\). Se \(\mathcal{F}\) dovesse risultare vuoto, allora il
risultato dell'intera operazione di \emph{meet} è un poliedro \(\bot\). Se al
contrario non fosse vuoto, aggiungo \(\mathcal{F}\) a \(\mathcal{O}\) per poi
riprender il ciclo fino all'esaurimento dei fattori e ritornando infine
\(\mathcal{O}\) e il suo blocco (rappresentato dal \emph{lub} di \(\pi_{\mathcal{P}}\) e
\(\pi_{\mathcal{Q}}\)) come risultato. \(\pi_{\mathcal{P} \sqcup
\mathcal{Q}} = \pi_{\mathcal{P}} \sqcap \pi_{\mathcal{Q}}\) è una partizione
ammissibile se \(\mathcal{P} \sqcap \mathcal{Q} \ne \bot\), altrimenti \(\bot\) è
ammissibile.

\begin{algorithm}[H]
\caption{Meet}\label{meet}
\begin{algorithmic}[1]
\Function{Meet}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{Q}, \pi_{\mathcal{Q}}$}
\State$\pi$ := $\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}$
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \pi$}
\State$\mathcal{Q}'$ := \Call{Refactor}{$\mathcal{Q}, \pi_{\mathcal{Q}}, \pi$}
\State$\mathcal{O}$ := $\emptyset$
\For{\textbf{each} $i$ \textbf{in} $\{1,...,r\}$}\Comment{r = numero di blocchi in $\pi$}
\If{$\mathcal{P}'_i = \mathcal{Q}'_i$}
\State$\mathcal{O}$.add$(\mathcal{P}'_i)$
\Else
\State$\mathcal{F}$ := $\mathcal{P}'_{i} \bowtie \mathcal{Q}'_{i}$
\If{\Call{is\_empty}{$\mathcal{F}$}}
\State\Return$\bot, \bot$
\EndIf
\State$\mathcal{O}$.add$(\mathcal{F})$
\EndIf
\EndFor
\State$\pi_{\mathcal{O}}$ := $\pi$
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}


\subsection{Conditional}
\label{sec:org688625f}
Questa operazione viene utilizzata per aggiungere nuovi vincoli tra le variabili
di un poliedro. Tramite la doppia rappresentazione è possibile aggiungendo un
vincolo arbitrario \(c\) all'insieme \(\mathcal{C}_{\mathcal{P}}\). Se dopo
l'inserimento il sistema di vincoli risulta insoddisfacibile allora il poliedro
diventa vuoto. Il sistema di generatori è, come sempre, ricavato dall'aggiunta
incrementale del vincolo \(c\) nel poliedro attraverso la conversione.

Utilizzando poliedri fattorizzati è necessario ricavare il blocco \(\mathcal{B}\) che contiene le
variabili utilizzate nel vincolo, rifattorizzando \(\mathcal{P}\) con
\(\pi_{\mathcal{P}} \uparrow \mathcal{B}\) si genera \(\mathcal{P}'\).
Successivamente bisogna prendere il fattore relativo contenente le variabili di
\(\mathcal{B}\), convertire il vincolo con le dimensioni \emph{interne} del fattore e
aggiungerlo a quest'ultimo utilizzando un'operazione per normali poliedri. Si
controlla, infine, che il sistema di vincoli sia ancora soddisfacibile e, in
caso negativo i blocchi e i fattori vengono modificati in \(\bot\) rendendo il
poliedro \emph{vuoto}. È importante far notare che, dato \(\mathcal{O}\) un poliedro
risultante dall'aggiunta di un vincolo, \(\pi_{\mathcal{O}} = \pi_{\mathcal{P}}
\uparrow \mathcal{B}\) è ammissibile se \(\mathcal{O} \ne \bot\), altrimenti
\(\pi_{\mathcal{O}} = \bot\).

\begin{algorithm}[H]
\caption{Conditional}\label{conditional}
\begin{algorithmic}[1]
\Function{Conditional}{$con$}
\State$\mathcal{B}$ := \Call{extract\_block}{$\mathcal{P}$, $\pi_{\mathcal{P}}$, \textit{con}}
\State$\pi$ := $\pi_{\mathcal{P}} \uparrow \mathcal{B}$
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \pi$}
\State$\mathcal{O}$ := $\emptyset$
\For{\textbf{each} $i$ \textbf{in} $\{1,...,r\}$}\Comment{r = numero di blocchi in $\pi$}
\If{$\mathcal{B} \cap \pi_i \ne \emptyset$}
\State$con_{int}$ := \Call{convert\_con}{$\pi_i$, \textit{con}}
\State$\mathcal{F}$ := \Call{add\_con}{$\mathcal{P}'_i, con_{int}$}
\State$\mathcal{O}$.add$(\mathcal{F})$
\If{\Call{is\_empty}{$\mathcal{O_{i}}$}}
\State\Return$\bot, \bot$
\EndIf
\Else
\State$\mathcal{O}$.add$(\mathcal{P'_i})$
\EndIf
\EndFor
\State$\pi_{\mathcal{O}}$ := $\pi$
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Assignment}
\label{sec:orgbf4716c}
Per quanto riguarda il dominio dei poliedri fattorizzati, l'operazione di
\emph{assignment} è molto simile alla \emph{conditional}. Dopo aver estratto il blocco
\(\mathcal{B}\) che indica le variabili utilizzate nell'espressione lineare, si
fattorizza il poliedro \(\mathcal{P}\) con \(\pi_{\mathcal{P}} =
\pi_{\mathcal{P}} \uparrow \mathcal{B}\) ottenendo \(\mathcal{P}'\),
successivamente si prende il blocco con le variabili di \(\mathcal{B}\) e si
applica al relativo fattore un \emph{assignment} come per i poliedri non
fattorizzati, rimappando correttamente le variabili esterne rispetto a quelle
interne al fattore. La partizione ammissibile per un poliedro risultante da
questa operazione è \(\pi_{\mathcal{P}} \uparrow \mathcal{B}\).

\begin{algorithm}[H]
\caption{Assignment}\label{assignment}
\begin{algorithmic}[1]
\Function{Assignment}{$\mathcal{P}$, $\pi_{\mathcal{P}}, stmt$}
\State let $stmt = (x_{i} = ax + \epsilon) $
\State$\mathcal{B}$ := \Call{extract\_block}{$stmt$}
\State$\pi$ := $\pi_{\mathcal{P}} \uparrow \mathcal{B}$
\State$\mathcal{P}'$ := \Call{refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \pi$}
\State$\mathcal{O}$ := $\emptyset$
\For{\textbf{each} $i$ \textbf{in} $\{1,...,r\}$}\Comment{$r$ = numero di blocchi in $\pi$}
\If{$\pi_i \subseteq \mathcal{B}$}
\State$stmt_{int}$ := \Call{convert}{$\pi, stmt$}
\State$\mathcal{F}$ := \Call{assignment}{$\mathcal{P}'_i, stmt_{int}$}\Comment{Poliedri non fattorizzati}
\State $\mathcal{O}$.add$(\mathcal{F})$
\If{$\mathcal{P}'_i$ := $\emptyset$}
\State\Return$\bot,\bot$
\EndIf
\Else
\State $\mathcal{O}$.add$(\mathcal{P}'_i)$
\EndIf
\EndFor
\State\Return $\mathcal{O}, \pi$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Widening (\(\nabla\))}
\label{sec:orgb73fa74}
Per la doppia rappresentazione, l'operatore di \emph{widening} necessita come
parametri i generatori e i vincoli di \(\mathcal{P}\) e i vincoli di
\(\mathcal{Q}\). Il risultato dell'operazione \(\mathcal{P} \nabla
\mathcal{Q}\) conterrà i vincoli \(\mathcal{C}_{\mathcal{Q}}\) che sono presenti in
\(\mathcal{C}_{\mathcal{P}}\) o che possono sostituirne un vincolo senza cambiare
\(\mathcal{P}\).

Per implementarlo è necessario effettuare una rifattorizzazione \(\mathcal{P}'\)
del primo argomento \(\mathcal{P}\) con \(\pi = \pi_{\mathcal{P}} \sqcup
\pi_{\mathcal{Q}}\), mentre non è necessario rifattorizzare il secondo argomento.
Successivamente, per ogni fattore \(\mathcal{Q}_i\) del secondo argomento si
individua il fattore corrispondente \(\mathcal{P}'_k\) in \(\mathcal{P}'\) e si
procede a individuare l'insieme \(\mathcal{C}_{\mathcal{O}_i}\) di vincoli di
\(\mathcal{Q}_i\) che sono \emph{stabili} rispetto a \(\mathcal{P}'_k\): questi vincoli
costituiscono il risultato del widening rispetto a quel fattore.
Come caso speciale, se \(\pi_{\mathcal{P}'_k} = \pi_{\mathcal{Q}_i}\), allora è
possibile applicare direttamente l'operatore di widening per poliedri non
fattorizzati.

\begin{algorithm}[H]
\caption{Widening}\label{widening}
\begin{algorithmic}[1]
\Function{Widenind}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{Q}, \pi_{\mathcal{Q}}$}
\State $\pi$ := $\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}$
\State $\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \pi$}
\State $\mathcal{O}$ := $\emptyset$
\For{\textbf{each} $i$ \textbf{in} $\{1,...,r\}$}\Comment{$q$ = numero di blocchi in $\pi_{\mathcal{Q}}$}
\State $\mathcal{C}_{\mathcal{O}_i}$ := $\emptyset$
\State $k$ := $j$, t.c. $\mathcal{X}_{\mathcal{Q}_i} \subseteq \mathcal{X}_j, \mathcal{X}_j \in \pi$
\If{$\pi_k = \pi_{\mathcal{Q}_i}$}
\State $\mathcal{Q}_i$ := \Call{Widening}{$\mathcal{P}'_k, \mathcal{Q}_i$}
\Else
\State $\mathcal{C}_{\mathcal{O}_i}$ := \Call{select\_stable\_con}{$\mathcal{C}_{\mathcal{Q}_i}, \mathcal{P}'_k$}
\State $\mathcal{Q}_i$ := \Call{new\_factor}{$\mathcal{C}_{\mathcal{O}_i}$}
\EndIf
\State $\mathcal{O}$.add$(\mathcal{O}_i)$
\EndFor
\State\Return $\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\chapter{Implementazione}
\label{sec:org55b03df}
Questo capitolo tratterà dell'implementazione effettiva dei poliedri
fattorizzati e di alcune loro operazioni. La struttura è stata basata su di un
\emph{wrapper} preesistente nella \emph{PPlite} mentre alcune delle implementazioni sono
state attuate effettuando un porting dalla libreria \emph{PPL}. La maggior parte delle
operazioni sono state sviluppate come un wrapper per la \emph{PPLite}, difatti le
operazioni sui singoli poliedri sono gestite da essa. Lo scopo principale è
quello di inserirsi all'interno dell'analisi statica e utilizzare i poliedri
fattorizzati se e quando vengono generati poliedri che implicano un alto
overhead per essere gestiti, in questo caso i suddetti poliedri vengono
fattorizzati in maniera tale da diminuire il carico computazionale.
L'implementazione è stata sviluppata interamente in \emph{C++11} con l'obiettivo di
utilizzare i metodi della \emph{libreria standard} così da incrementare la leggibilità
del codice. L'efficienza non è stata presa come obiettivo principale durante lo
sviluppo, dando importanza alla correttezza e alla leggibilità del codice.

Durante l'implementazione è stata seguita una metodologia che è possibile suddividere in tre fasi:

\begin{enumerate}
\item inizialmente è stato effettuato un porting del codice dalla \emph{PPL} alla
\emph{PPLite}, con adattamento alle strutture dati di quest'ultima;
\item successivamente è stato attuato un adeguamento incrementale agli standard di
naming e codifica usati nella PPLite;
\item infine si è rivisto il codice scritto e si ci è apprestati a semplificarlo
tramite l'utilizzo più sistematico di algoritmi della libreria standard e
funzioni di supporto della PPLite. Questo ha permesso di avere un codice più
corto e più facile da leggere.
\end{enumerate}

\section{\texttt{F\_Poly}}
\label{sec:org18ce836}
La classe dove sono compresi gran parte dei metodi è \texttt{F\_Poly}. È stata
definita nel file \texttt{F\_Poly.hh} dove sono presenti 92 metodi pubblici e 14 metodi
privati.

Per la costruzione/distruzione degli oggetti è stata seguita la
\emph{Rule of Five}, quindi abbiamo:

\begin{itemize}
\item un costruttore esplicito, un costruttore per copia, un costruttore per spostamento;
\item operazioni di assegnamento per copia e per spostamento;
\item un distruttore.
\end{itemize}

In particolare, ci si è assicurati che il costruttore e l'assegnamento per
spostamento, generati in automatico dal compilatore, fossero dichiarati \texttt{noexcept}: questo è richiesto allo scopo di
evitare l'uso di copie costose quando si utilizzano alcuni contenitori e
algoritmi della \emph{STL}.

Abbiamo anche:

\begin{itemize}
\item un metodo \texttt{check\_inv()} per controllare che l'invariante di classe non sia
stata violata;
\item le operazioni principali descritte nella sezione 2.3;
\item funzioni di appoggio per gestire il poliedro.
\end{itemize}

Sono presenti delle strutture dati per la gestione dei fattori:

\begin{itemize}
\item \texttt{block} di tipo \texttt{Block}: un \texttt{std::vector} di \texttt{dim\_type} che rappresenta un blocco \(\mathcal{X}_i\) che
contiene alcune dimensioni del poliedro;
\item \texttt{blocks} di tipo \texttt{Blocks}: un \texttt{std::vector} di \texttt{Block}, che esprime la partizione del poliedro;
\item \texttt{factor} di tipo \texttt{Factor}: un fattore è un poliedro, difatti \texttt{Factor} è un alias per oggetti di tipo \texttt{Poly};
\item \texttt{factors} di tipo \texttt{Factors}: un \texttt{std::vector} di \texttt{Factor}, ognuno dei quali in
corrispondenza posizionale con il corrispondente blocco in \texttt{blocks}.
\end{itemize}

Sono inoltre presenti tre variabili:

\begin{itemize}
\item \texttt{dim\_type dim}: indicante le dimensioni del poliedro;
\item \texttt{Topol topol}: indicante la topologia del poliedro;
\item \texttt{bool is\_empty}: indicante se il poliedro è vuoto o no.
\end{itemize}

\subsection{\texttt{check\_inv}}
\label{sec:orgb84b040}
Il metodo menzionato contiene tutti i controlli necessari per verificare che
l'invariante di classe non sia stata violata, e che quindi il poliedro su cui si
sta lavorando è ben formato. Le invarianti di classe che devono
essere rispettate sono le seguenti:

\begin{itemize}
\item la dimensione del poliedro deve essere \(\ge 0\)
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
if (dim < 0) {
  reason = "F_Poly broken: invalid space dimension";
  maybe_dump();
  return false;
}
\end{lstlisting}
;
\item se il poliedro è vuoto, i fattori e i blocchi devono essere anch'essi vuoti
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
if (is_empty()) {
  if (!(factors.empty() && blocks.empty())) {
    reason = "F_Poly broken: empty polyhedron has factors";
    maybe_dump();
    return false;
  }
  // No other check for an empty polyhedron.
  return true;
}
\end{lstlisting}
;
\item il numero di blocchi deve essere uguale al numero di fattori
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
if (factors.size() != blocks.size()) {
  reason = "F_Poly broken: #factors != #blocks";
  maybe_dump();
  return false;
}
\end{lstlisting}
;
\item la cardinalità totale dei blocchi deve essere uguale a \texttt{dim}
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
dim_type dim_ = 0;
for (const auto& block : blocks)
  dim_ += block.size();
if (dim != dim_) {
  reason = "F_Poly broken: space dimension mismatch";
  maybe_dump();
  return false;
}
\end{lstlisting}
;
\item la dimensione di un fattore deve essere uguale alla dimensione del blocco
che lo rappresenta
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
// Each factor space dim should match its block.
for (dim_type i = 0; i < num_rows(factors); ++i)
  if (factors[i].space_dim() != num_rows(blocks[i])) {
    reason = "F_Poly broken: factor vs block space dim mismatch";
    maybe_dump();
    return false;
  }
\end{lstlisting}
;
\item nessun fattore deve essere vuoto
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
if (std::any_of(factors.begin(), factors.end(),
                std::mem_fn(&Poly::is_empty))) {
  reason = "F_Poly broken: empty factor";
  maybe_dump();
  return false;
}
\end{lstlisting}
;
\item ogni dimensione dello spazio deve apparire una e una volta soltanto nei
blocchi e non devono esserci blocchi vuoti (ovvero, \texttt{blocks} codifica solo una
partizione)
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
std::vector<bool> dims(dim, false);
for (const auto& block : blocks) {
  if (block.size() == 0) {
    reason = "F_Poly broken: found empty block";
    maybe_dump();
    return false;
  }
  for (const auto d : block) {
    if (d < 0 || d >= dim) {
      reason = "F_Poly broken: block contains an illegal
                space dim";
      maybe_dump();
      return false;
    }
    if (dims[d]) {
      reason = "F_Poly broken: repeated space dim in blocks";
      maybe_dump();
      return false;
    }
    dims[d] = true;
  }
}
\end{lstlisting}
;
\item ogni dimensione dello spazio deve essere presente in un blocco
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
if (std::find(dims.begin(), dims.end(), false) != dims.end()) {
  reason = "F_Poly broken: a space dim is missing from blocks";
  maybe_dump();
  return false;
}
\end{lstlisting}
.
\end{itemize}

\section{Operazioni di base}
\label{sec:orgcfd297b}
In questa sezione verranno descritte le funzione che più vengono utilizzate
all'intendo di \texttt{F\_Poly.cc}:

\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
static Factors refactor(const Factors& f,
                        const Blocks& b1, const Blocks& b2);
static Blocks least_upper_bound(const Blocks& b1, const Blocks& b2);
static Blocks merge(const Blocks& b, const Block& added);
\end{lstlisting}

\subsection{\texttt{refactor}}
\label{sec:org4edc096}
La semantica rimane invariata invariata rispetto a quanto descritto
nell'Algoritmo \ref{refactor}. Per la \emph{join} \((\bowtie)\) tra i fattori è stata
utilizzata la \texttt{concatenate\_assign()} della PPlite; una funzione omonima, per
quanto riguarda il join dei blocchi, è stata implementata utilizzando
\texttt{std::vector::insert}. E importante notare che questa operazione è
ammissibile in quanto non c'è alcuna possibilità di dimensioni doppie
all'interno dei blocchi interessati.

\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
Blocks bs(bs2.size());
  Factors res(bs.size(), Factor(0, Spec_Elem::UNIVERSE));
  for (dim_type i = 0; i != num_rows(bs1); ++i)
    for (dim_type j = 0; j != num_rows(bs2); ++j) {
      if (detail::are_disjoint(bs1[i], bs2[j]))
        continue;
      res[j].concatenate_assign(fs[i]);
      concatenate_assign(bs[j], bs1[i]);
    }
\end{lstlisting}

Per rimappare le dimensioni in maniera corretta viene utilizzata la funzione
\texttt{map\_space\_dims()}, che prende come argomento un oggetto di tipo \texttt{Dims} che
viene riempito delle varie dimensioni dei blocchi che saranno rimappati in base
all'indice in cui si trovano.

\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
// Remap those factors res[i] s.t. bs[i] != bs2[i]
  for (dim_type i = 0; i != num_rows(bs2); ++i) {
    const auto& b = bs[i];
    const auto& b2 = bs2[i];
    assert(b.size() == b2.size());
    if (b == b2)
      continue;
    Dims pf(b.size());
    for (auto j = b.size(); j-- > 0; )
      pf[b[j]] = b2[j];
    res[i].map_space_dims(pf);
  }
  return res;
\end{lstlisting}

Il metodo \texttt{are\_disjoint(const Block\& b1, const Block\& b2)} viene utilizzato per
vedere se due blocchi hanno almeno una variabile in comune:

\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
inline bool
are_disjoint(const Block& b1, const Block& b2) {
  return std::find_first_of(b1.begin(), b1.end(),
                            b2.begin(), b2.end()) == b1.end();
}
\end{lstlisting}

Utilizza \texttt{std::find\_first\_of} e ritorna \texttt{true} se non trova alcun elemento del
primo insieme nel secondo.

\subsection{\texttt{least\_upper\_bound}}
\label{sec:orgd003e21}
L'implementazione di questo metodo non è stata menzionata in \cite{fastpoly} ma
ne è stato solo descritto l'aspetto matematico. In termini più pratici questa
operazione prende due parametri \texttt{const Blocks\& b1, const Blocks\& b2} e,
inizialmente, crea un blocco \texttt{lub} che sarà composto dalle variabili non in
comune tra \texttt{b1} e \texttt{b2}:

\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
F_Poly::Blocks
F_Poly::least_upper_bound(const Blocks& b1, const Blocks& b2) {
  Blocks lub; dim_type i = 0;
  bool first = true;

  for (const auto &bl1 : b1)
    for (const auto &bl2 : b2)
      if (!detail::are_disjoint(bl1, bl2)) {
        if (first) {
          lub.push_back(bl2);
          first = false;
        }
        else {
          lub[i] = block_union(lub[i], bl2);
        }
        ++i;
        first = true;
      }
\end{lstlisting}

Successivamente si itera su \texttt{lub} per unire i blocchi che presentavano
dimensioni comuni fino a costruire la partizione \texttt{lub}.

\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
  for (auto it1 = lub.begin(); it1 != lub.end(); ++it1)
    for (auto it2 = it1 + 1; it2 != lub.end(); ++it2)
      if (!detail::are_disjoint(*it1, *it2)) {
        *it1 = block_union(*it1, *it2);
        lub.erase(it2);
        --it2;
      }
\end{lstlisting}

Per unire i blocchi è stata utilizzata al funzione \texttt{block\_union(const Block\& b1,
const Block\& b2)} che permette di unire i blocchi ed evitare che si vengano a
creare dimensioni doppie.

\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
F_Poly::Block
F_Poly::block_union(const Block& b1, const Block& b2) {
  Block out(b1);
  bool add = true;
  for (const auto dim2 : b2) {
    for (const auto dim1 : b1)
      if (dim1 == dim2) {
        add = false;
        break;
      }
    if (add)
      out.push_back(dim2);
    else
      add = true;
  }
  return out;
}
\end{lstlisting}

\subsection{\texttt{merge}}
\label{sec:orgeb852ef}
La funzione \texttt{merge} prende due parametri, un \texttt{Blocks b} e un \texttt{Block added} e
genera un \texttt{Blocks out} che consiste nell'unione di \texttt{b} e \texttt{added}. La funzione
cicla sul primo parametro, e da qui può essere suddivisa in tre parti principali:

\begin{itemize}
\item si controlla se i blocchi \texttt{b[i]} e \texttt{added} hanno variabili in comune, in caso
positivo (se è la prima volta che si trovano blocchi non disgiunti) si
aggiunge \texttt{b[i]} ad \texttt{out}:
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
Blocks out;
bool first = true;
dim_type index = 0;
for (dim_type i = 0; i < num_rows(b); ++i) {
  if (!detail::are_disjoint(b[i], added)) {
    if (first) {
      out.push_back(b[i]);
      first = false;
      index = i;
    }
\end{lstlisting}
;
\item se i blocchi sono disgiunti ma non è la prima volta che se ne trovano:
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
   else {
     concatenate_assign(out[index], b[i]);
   }
\end{lstlisting}
;
\item se invece i blocchi sono disgiunti:
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
   else
     out.push_back(b[i]);
}
\end{lstlisting}
\end{itemize}
.

Infine si ritorna \texttt{out}.
\section{Operazioni sui poliedri}
\label{sec:org0dbafe1}
Qui verranno mostrate le implementazioni delle operazioni discusse nella Sezione
2.3.

\subsection{\texttt{inclusion}}
\label{sec:org683bda7}
Come descritto nella Sezione 2.3.1, questa operazione è utile per controllare se
un poliedro è incluso in un altro.

La funzione prende come parametri un insieme
di fattori e i loro relativi blocchi. Si calcola il \emph{lub} tra i
blocchi passati come parametri e i blocchi di \texttt{this}, il risultato è utilizzato
per rifattorizzare i fattori di \texttt{this} (in un nuovo insieme di
fattori P) e i fattori passati come parametro (in un nuovo insieme di fattori
Q). Una volta fatto ciò non si fa altro che scorrere i vari fattori e
richiamare la funzione \texttt{contains} della \emph{PPLite}.

\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
bool
F_Poly::inclusion(const Factors& f, const Blocks& b) const {
  Blocks b_lub = least_upper_bound(blocks, b);
  Factors P = refactor(factors, blocks, b_lub);
  Factors Q = refactor(f, b, b_lub);

  for (const auto& P_factor : P)
    for (const auto& Q_factor : Q)
      if(!P_factor.contains(Q_factor))
        return false;

  return true;
}
\end{lstlisting}
\subsection{\texttt{join}}
\label{sec:orge44a0cf}
Questa operazione permette di unire due poliedri. La funzione prende due
parametri: un insieme di fattori \texttt{fs} e i suoi blocchi \texttt{bs}. La sua implementazione può
essere suddivisa in tre fasi:

\begin{enumerate}
\item inizialmente vengono creati tutti li oggetti necessari:
\begin{itemize}
\item \texttt{Pr} e \texttt{Qr} sono i due insiemi di fattori che conterranno i
poliedri di \texttt{this} e di \texttt{fs}, entrambi rifattorizzati in base ai lori
rispettivi blocchi e al \emph{lub} tra \texttt{blocks} e \texttt{bs};
\item \texttt{O} e \texttt{U} saranno, rispettivamente, i fattori e i blocchi finali
(contenenti quindi il risultato della funzione);
\item \texttt{Pt}, \texttt{Qt} e \texttt{bpo} sono oggetti temporanei il cui scopo verrà spiegato
successivamente.
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
   Factors Pr;
   Factors Qr;
   Factors O = Factors();
   Factor Pt;
   Factor Qt;
   Block bpo = Block();
   Blocks U = Blocks();
   Blocks lub = least_upper_bound(blocks, bs);
   bool first = true;
   Pr = refactor(factors, blocks, lub);
   Qr = refactor(fs, bs, lub);
\end{lstlisting}
\end{itemize}
\item successivamente si procede alla costruzione dei vari poliedri che andranno a
formare il join finale. Inizialmente si controlla, per ogni poliedro, se
\texttt{Pr[i] = Qr[i]}, se sono uguali allora dentro \texttt{O} e \texttt{U} vengono inseriti
rispettivamente \texttt{Pr[i]} e il suo blocco:
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
for (dim_type i = 0; i < num_rows(Pr); ++i) {
  if (Pr[i] == Qr[i]) {
    O.push_back(Pr[i]);
    U.push_back(lub[i]);
  }
\end{lstlisting}
se non sono uguali ed è la prima volta che si verifica
questa situazione, i blocchi \texttt{Qr[i]} e \texttt{Rr[i]} vengono inseriti
rispettivamente negli oggetti temporanei \texttt{bpo}, \texttt{Qt} e \texttt{Pt}:
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
else {
  if (first) {
    bpo =lub[i];
    Qt = Qr[i];
    Pt = Pr[i];
    first = false;
\end{lstlisting}
se invece non è la prima volta, vengono semplicemente concatenati invece che
aggiunti:
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
else {
  concatenate_assign(bpo, lub[i]);
  Pt.concatenate_assign(Pr[i]);
  Qt.concatenate_assign(Qr[i]);
}
\end{lstlisting}
\item a questo punto è necessario aggiungere a \texttt{O} e \texttt{U} i poliedri che sono
risultati essere differenti nel punto precedente. Infine alle strutture in
\texttt{this} si assegnano i poliedri e blocchi su cui è stato applicato il join:
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
Pt.poly_hull_assign(Qt);
U.push_back(bpo);
O.push_back(Pt);
factors = O;
blocks = U;
dim = space_dim(blocks);
\end{lstlisting}
\end{enumerate}
\subsection{\texttt{add\_con}}
\label{sec:org0b9f0cc}
Il metodo \texttt{add\_con} non è altro che l'implementazione dell'Algoritmo
\ref{conditional}. Per poter sviluppare questa operazione sono necessaire due diverse
funzioni helper oltre a \texttt{refactor} e \texttt{merge}:

\begin{itemize}
\item \texttt{extract\_block()}: una funzione che, preso un vincolo, restituisce il blocco
contenente tutte le variabili utilizzate in esso:
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
inline Block
extract_block(const Linear_Expr& e) {
  Block var_block;
  for (dim_type i = 0; i != e.space_dim(); ++i)
    if (e.get(Var(i)) != 0)
      var_block.push_back(i);
  return var_block;
}
\end{lstlisting}
non facciamo altro che iterare una \texttt{Linear\_Expr} inserendo tutte le variabili
presenti in quest'ultima in un \texttt{std::vector}.
\item \texttt{convert}: è una funzione che permette di mappare le dimensioni di un vincolo.
Definendo come \emph{esterne} le dimensioni del poliedro nella sua interezza e
\emph{interne} quelle di un suo fattore, questo metodo effettua la traduzione da
vincolo esterno a vincolo interno in base al blocco che viene passato.
\end{itemize}

Inizialmente viene creato un blocco \texttt{b} che conterrà le variabili utilizzate nel
vincolo \texttt{c} passato come parametro alla funzione. Successivamente possono
presentarsi due casi nel caso in cui il \texttt{b} sia vuoto:
\begin{itemize}
\item se il vincolo è tautologico, quindi vero in ogni possibile interpretazione, si ritorna;
\item se il vincolo è incosistente, il poliedro viene settato a \texttt{empty} e si
ritorna.
\end{itemize}

\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
void
F_Poly::add_con(const Con& c) {
  if (is_empty())
    return;

  Block b = detail::extract_block(c);
  if (b.size() == 0) {
    if (c.is_tautological())
      return;
    else {
      assert(c.is_inconsistent());
      set_empty();
      return;
    }
  }
\end{lstlisting}

Se invece \texttt{b} non è vuoto si procede con l'aggiunta del vincolo al poliedro.

Inizialmente viene fatto un merge tra i blocchi del poliedro e il blocco \texttt{b}
calcolato precedentemente, successivamente si rifattorizza in base al blocco
risultante dal merge e, quest'ultimo, sostituirà i blocchi "vecchi" del
poliedro.

Una volta fatto ciò, si cicla all'interno dei blocchi e, non appena si trova un
blocco non disgiunto dal blocco \texttt{b}, si definisce la variabile \texttt{c\_int} che
conterrà il vincolo \texttt{c} ma con le variabili adattate a quelle del blocco
\texttt{blocks[i]}, successivamente si aggiunge il vincolo utilizzando la funzione
\texttt{add\_con} della classe \texttt{Poly} e, se dopo aver aggiunto il vincolo il fattore
risultasse vuoto, allora il poliedro viene settato a \texttt{empty}.

\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
  Blocks blocks_out = merge(blocks, b);
  factors = refactor(factors, blocks, blocks_out);
  blocks = blocks_out;

  for (dim_type i = 0; i != num_rows(blocks); ++i) {
    if (detail::are_disjoint(b, blocks[i]))
      continue;
    Con c_int = detail::convert(c, blocks[i]);
    factors[i].add_con(std::move(c_int));
    if (factors[i].is_empty()) {
      set_empty();
      return;
    }
  }
}
\end{lstlisting}

\subsection{\texttt{affine\_image} e \texttt{affine\_preimage}}
\label{sec:orgc1ccc9e}
La funzione \texttt{affine\_image} è l'implementazione dell'operazione \emph{assignment} vista
nell'Algoritmo \ref{assignment}. A differenza di quest'ultimo, per rimanere
coerenti con le definizioni della PPLite, la funzione prende in input:

\begin{itemize}
\item Una variabile \texttt{var} di tipo \texttt{Var};
\item Un'espressione lineare \texttt{expr} di tipo \texttt{Linear\_Expr};
\item Un intero \texttt{inhomo} di tipo \texttt{Integer} che rappresenta il \emph{termine noto};
\item Un intero \texttt{den} di tipo \texttt{Integer} che rappresenta il \emph{denominatore}.
\end{itemize}

Questi parametri formeranno lo statement \(var = \frac{expr}{den} + inhomo\)
equivalente a \(x_i = ax + \epsilon\) dell'Algoritmo \ref{assignment}. Le uniche
differenze con lo pseudocodice sono che è necessario convertire sia \texttt{var} che
\texttt{expr} in base al blocco corrispondente. Una volta convertite non si fa altro
che chiamare la \texttt{affine\_image} della PPLite per ogni fattore.


\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
void
F_Poly::affine_image(Var var, const Linear_Expr& expr,
                     const Integer& inhomo,
                     const Integer& den) {
  Block b = detail::extract_block(expr);
  detail::add_var(b, var);
  Blocks bs_out = merge(blocks, b);
  factors = refactor(factors, blocks, bs_out);
  blocks = bs_out;
  for (dim_type i = 0; i < num_rows(factors); ++i) {
    if (detail::are_disjoint(b, blocks[i]))
      break;
    Var v_int = detail::convert(var, blocks[i]);
    Linear_Expr le_int = detail::convert(expr, blocks[i]);
    factors[i].affine_image(v_int, le_int, inhomo, den);
    if (factors[i].is_empty())
      set_empty();
  }
}
\end{lstlisting}

La funzione \texttt{affine\_preimage} è identica a quella appena descritta, con l'unica
differenza di chiamare la \texttt{affine\_preimage} della PPLite per ogni fattore.

\section{Altre operazioni}
\label{sec:org392ce0f}
Oltre alle operazioni descritte in \cite{fastpoly} ne sono state aggiunte altre
per rendere più completa la classe. Tutte le operazioni descritte
successivamente non sono altro che il corrispettivo sui poliedri fattorizzati di
metodi omonimi presenti nella PPLite.

\subsection{\texttt{add\_space\_dims} e \texttt{remove\_space\_dims}}
\label{sec:orgba78fd8}
Funzioni che permettono l'aggiunta e la rimozione di dimensioni del poliedro. Ne
sono state implementate tre versioni:

\begin{itemize}
\item \texttt{add\_space\_dims}: permette di aggiungere \(n\) (con \(n\) parametro della
funzione) dimensioni al poliedro.
Quest'ultimo viene incorporato nel nuovo spazio vettoriale. Avendo dei fattori
implica che per ogni dimensione aggiunta deve essere aggiunto un nuovo blocco
singoletto contenente la nuova dimensione e un rispettivo fattore \emph{universo}
di dimensione 1. È presente anche un parametro \texttt{bool project} (settato a
\texttt{false} di default) che permette, se passato come \texttt{true}, di non incorporare il
poliedro nel nuovo spazio vettoriale. Difatti, per ogni dimensione aggiunta
viene creato un blocco singoletto che contiene la dimensione \texttt{dim} del
poliedro, mentre il fattore viene creato da un sistema di vincoli che indica
che la sua unica dimensione è vincolata ad assumere il valore 0:
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
void
F_Poly::add_space_dims(dim_type m, bool project) {
  assert(m >= 0);
  if (m == 0)
    return;
  if (is_empty()) {
    dim += m;
    return;
  }
  Factor f(1, Spec_Elem::UNIVERSE, topology());
  if (project)
    f.add_con(Var(0) == 0);
  factors.insert(factors.end(), m, f);
  for (dim_type i = 0; i != m; ++i) {
    blocks.emplace_back(1, dim);
    ++dim;
  }
}
\end{lstlisting}
\item \texttt{remove\_space\_dim}: permette di rimuovere una dimensione dal poliedro. Il
problema principale è che, rimuovendo una dimensione, è necessario
riorganizzare i blocchi in modo tale da essere uniformati all'insieme
\(\{1,...,dim\}\). Questa operazione è riservata a una funzione chiamata
\texttt{reduce\_blocks}.

La funzione inizia con un doppio ciclo \texttt{for} che permette di scorrere
all'interno di ogni blocco del poliedro. Per ogni blocco, se il valore di
\texttt{blocks[i][j]} è uguale a \texttt{v}, possiamo avere diverse casistiche:

\begin{itemize}
\item il blocco \texttt{blocks[i]} è formato da un singolo elemento: in questo caso viene
eliminato tutto il blocco e il corrispondente fattore;
\item il blocco \texttt{blocks[i]} è formato da più elementi: in questo caso viene
eliminato solo il j-esimo elemento dell'i-esimo blocco, il fattore viene
gestito tramite la \texttt{remove\_space\_dim} della classe \texttt{Poly}.
\end{itemize}
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
void
F_Poly::remove_space_dim(const dim_type v) {
  for (dim_type i = 0; i < num_rows(blocks); ++i)
    for (dim_type j = 0; j < num_rows(blocks[i]); ++j)
      if (v == blocks[i][j]) {
        if (num_rows(blocks[i]) == 1) {
          blocks.erase(blocks.begin() + i);
          factors.erase(factors.begin() + i);
          reduce_blocks(blocks, v);
        }
        else {
          blocks[i].erase(blocks[i].begin() + j);
          factors[i].remove_space_dim(Var(v));
          reduce_blocks(blocks, v);
        }
        --dim;
        return;
      }
}
\end{lstlisting}
È presente anche la versione \texttt{remove\_space\_dims(const Index\_Set\& vars)} che
permette di rimuovere tutte le dimensioni presenti dentro \texttt{vars}.
\item \texttt{remove\_higher\_space\_dims}: è una variante della funzione
precedente, rimuove le \(n\) dimensioni (con \(n\) parametro
della funzione) più grandi del poliedro. È presente nel wrapper utilizzato in
quanto risulta essere più efficiente nella
classe \texttt{Poly}, per quanto riguarda \texttt{F\_Poly} non risulta esserlo considerato
che le dimensioni da rimuovere non sono necessariamente le ultime.
Viene implementata quindi utilizzando la funzione descritta precedentemente.
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
void
F_Poly::remove_higher_space_dims(dim_type new_dim) {
  if (is_empty()) {
    dim = new_dim;
    return;
  }
  for (dim_type i = space_dim(); i-- > new_dim; )
    remove_space_dim(i);
}
\end{lstlisting}
\end{itemize}

\subsection{\texttt{add\_gen}}
\label{sec:orgdb8f0e7}
Il metodo \texttt{add\_gen} viene utilizzato per aggiungere un generatore al poliedro.
Per ogni generatore che viene passato come parametro possono esserci tre casi:

\begin{itemize}
\item \textbf{Il poliedro è vuoto}: in questo caso si controlla che il generatore sia un
punto, successivamente tutto il poliedro viene settato come \emph{universo} e, per
ogni fattore, viene aggiunto un vincolo \(d \cdot \mathit{Var}(0) = \mathit{coeff}(\mathit{Var}(i))\)
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
if (is_empty()) {
  assert(g.is_point());
  *this = F_Poly(dim, Spec_Elem::UNIVERSE, topology());
  for (dim_type i = dim; i-- > 0; )
    factors[i].add_con(g.divisor() * Var(0) == g.coeff(Var(i)));
  assert(check_inv());
  return;
}
\end{lstlisting}
\item \textbf{Il poliedro non è vuoto e il generatore è un punto}: in questo caso non si fa
altro che costruire un insieme di fattori, ognuno dei quali conterrà il
generatore passato come parametro; infine questi fattori vengono aggiunti al
poliedro tramite la \emph{join}:
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
if (g.is_point()) {
  Factors fs_g;
  const auto nb = num_rows(blocks);
  fs_g.reserve(nb);
  for (dim_type i = 0; i != nb; ++i) {
    const auto& bi = blocks[i];
    const auto nbi = num_rows(bi);
    fs_g.emplace_back(nbi, Spec_Elem::UNIVERSE, topology());
    auto& fi = fs_g.back();
    for (dim_type j = 0; j != nbi; ++j)
      fi.add_con(g.divisor() * Var(j) == g.coeff(Var(bi[j])));
  }
  join(fs_g, blocks);
  assert(check_inv());
  return;
}
\end{lstlisting}
\item \textbf{Il poliedro non è vuoto e il generatore non è un punto}: in questo caso viene
creato un blocco \(\mathcal{B}\) contenente tutte le dimensioni che appaiono
nel generatore, successivamente si crea un blocco \(\pi =
  \pi_{\mathcal{P}} \uparrow \mathcal{B}\) tramite il quale si ri-fattorizza il
nostro poliedro in \(\mathcal{P}'\). Infine, per ogni blocco che compare anche
nel generatore si richiama la \texttt{add\_gen()} della PPLite
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
  assert(!is_empty() && !g.is_point());
  Block b_g = detail::extract_block(g);
  Blocks b_out = merge(blocks, b_g);
  factors = refactor(factors, blocks, b_out);
  blocks = b_out;

  for (dim_type i = 0; i != num_rows(blocks); ++i) {
    if (detail::are_disjoint(b_g, blocks[i]))
      continue;
    auto g_int = detail::convert(g, blocks[i]);
    factors[i].add_gen(std::move(g_int));
    break;
  }
  assert(check_inv());
\end{lstlisting}
\end{itemize}

\subsection{Predicati}
\label{sec:org1f3406c}
Sono presenti diversi predicati in \texttt{F\_Poly.hh} che permettono di controllare lo
stato del poliedro, i principali sono:
\begin{itemize}
\item \texttt{bool is\_empty} non fa altro che dire se il poliedro è vuoto o no;
\item \texttt{bool is\_minimized} controlla che tutti i fattori siano minimizzati, per farlo
viene utilizzato \texttt{std::all\_of} passando come predicato unario il puntatore
alla funzione \texttt{is\_minimized} della classe \texttt{Poly}:
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
bool is_minimized() const {
  return is_empty()
  || std::all_of(factors.begin(), factors.end(),
                 std::mem_fn(&Poly::is_minimized));
}
\end{lstlisting}
\item \texttt{bool is\_necessarily\_closed} dice se la topologia del poliedro è chiusa o no;
\item \texttt{bool is\_universe} dice se il poliedro è di tipo universo;
\item \texttt{bool is\_bounded} controlla se il sistema di equazioni che definisce il
poliedro è bounded
\item \texttt{bool equals(const F\_Poly\& y)} controlla se \texttt{this} è uguale a \texttt{y}.
Inizialmente viene calcolato il \emph{lub} tra i blocchi di \texttt{this} e \texttt{y},
successivamente vengono rifattorizzati i fattori in base al lub calcolato e
vengono assegnati a \texttt{fx} e \texttt{fy}, infine si controlla se ogni fattore in \texttt{fx}
è uguale a ogni fattore in \texttt{fy}:
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
bool
F_Poly::equals(const F_Poly& y) const {
  if (dim != y.space_dim())
    return false;
  if (is_empty() && y.is_empty())
    return true;

  Blocks b_lub = least_upper_bound(blocks, y.blocks);
  Factors fx = refactor(factors, blocks, b_lub);
  Factors fy = refactor(y.factors, y.blocks, b_lub);

  for (auto i = fx.size(); i-- > 0; )
    if (fx[i] != fy[i])
      return false;

  return true;
}
\end{lstlisting}
\end{itemize}

\subsection{Overload degli operatori}
\label{sec:org9034757}
È stato anche fatto un overload negli operatori \texttt{=} e \texttt{!=}, l'implementazione è
semplice e si basa sui predicati descritti nella sezione precedente:

\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
inline bool
operator==(const F_Poly& x, const F_Poly& y) {
  return x.equals(y); }

inline bool
operator!=(const F_Poly& x, const F_Poly& y) {
  return !(x == y); }
\end{lstlisting}
\chapter{Conclusione}
\label{sec:org9f06d4c}

\bibliographystyle{plain}
\renewcommand\bibname{Bibliografia}
\bibliography{mybib}
\end{document}

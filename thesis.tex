% Created 2019-02-19 mar 17:55
% Intended LaTeX compiler: pdflatex
\documentclass{mimosis}
 \usepackage{listings}
\usepackage{minted}
 \addto\captionsenglish{\renewcommand\contentsname{Indice}}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{float}
\usepackage[noend]{algpseudocode}
\KOMAoptions{fontsize=12pt,headings=normal}
\makeglossaries
\theoremstyle{definition}
\newtheorem{exmp}{Esempio}[section]
\usepackage{amsmath}
\floatname{algorithm}{Algoritmo}
\usepackage{listings}
\usepackage{color}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{backcolour}{RGB}{247,248,250}
\definecolor{codebrown}{RGB}{171,88,106}
\definecolor{codeblue}{RGB}{122,99,192}
\definecolor{codeorange}{RGB}{255,165,121}
\lstdefinestyle{mystyle}{
language=C++,
backgroundcolor=\color{backcolour},
commentstyle=\color{codegreen},
keywordstyle=\color{codeblue},
keywordstyle=[2]{\color{codeblue}},
morekeywords={Blocks, Block, Factor, Factors, dim_type,
Vars, Index_Set, Linear_Expr, Con, Cons, Gen,
Gens, Var, F_Poly},
numberstyle=\tiny\color{codegray},
stringstyle=\color{codeorange},
basicstyle=\footnotesize\ttfamily,
breakatwhitespace=false,
breaklines=true,
captionpos=b,
keepspaces=true,
numbers=none,
showspaces=false,
showstringspaces=false,
showtabs=false,
tabsize=2
}
\usepackage{unipr}
\titolo{Fattorizzazione Cartesiana nella libreria PPlite}
\titoloIng{Cartesian Factoring in the PPLite library}
\laureando{Luigi Zaccone}
\annoaccademico{2017-2018}
\corsodilaurea{Informatica}
\relatore[Chiar.mo Prof.]{Enea Zaffanella}

\newcommand{\mboxparagraph}[1]{\paragraph{#1}\mbox{}\\}
\newcommand{\mboxsubparagraph}[1]{\subparagraph{#1}\mbox{}\\}
\author{Luigi Zaccone}
\date{\today}
\title{La fattorizzazione cartesiana nella libreria PPLite}
\hypersetup{
 pdfauthor={Luigi Zaccone},
 pdftitle={La fattorizzazione cartesiana nella libreria PPLite},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.1 (Org mode 9.2)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\chapter{Introduzione}
\label{sec:orgacfba4e}

\chapter{Fattorizzazione cartesiana}
\label{sec:orgd4b3fe6}
La fattorizzazione cartesiana permette di avere una complessità di esecuzione
minore sulle operazioni applicate ai poliedri. L'idea è che i poliedri
utilizzati nell'analisi dei programmi non mettono in relazione tutte le
variabili del programma in un solo vincolo. Per esempio: un ipercubo \\
\(H_n = \{0 \le x_i \le 1 \; | \; i = 1,...,n\}\)
richiede \(2^n\) generatori per essere rappresentato, tramite la decomposizione
invece ne sono necessari solo \(2n\). La terminologia e gli esempi saranno
ispirati al lavoro svolto in \cite{fastpoly}.

\section{Blocchi e fattori}
\label{sec:org792c9df}
Sia \(\mathcal{X} = \{x_1, x_2,..., x_n\}\) un insieme di \(n\) variabili. Dato un poliedro, \(\mathcal{X}\)
può essere partizionato in un sottoinsieme \(\mathcal{X}_k\) che chiamiamo \emph{blocchi} tale
che i vincoli esistono solo tra variabili presenti nello stesso \emph{blocco}.
Quindi, ogni variabile priva di vincoli risiede in un singoletto. Ci riferiamo a
questo insieme come \(\pi = \pi_P = \{\mathcal{X}_1, \mathcal{X}_2,..., \mathcal{X}_t\}\).

\begin{exmp}
Consideriamo
\begin{align*}
  &\mathcal{X} = \{x_1, x_2, x_3\} ~{}e \\
  &P = \{x_1 + 2x_2 \le 3\}.
\end{align*}

In questo caso $\mathcal{X}$ viene partizionato in due blocchi: $\mathcal{X}_1 = \{x_1, x_2\}$ e
$\mathcal{X}_2 = \{x_3\}$.
\end{exmp}

Per ogni blocco, quindi, sarà presente un \emph{fattore} \(P_k\) che sarà composto solo
dalle variabili presenti nel suo blocco. In qualsiasi momento il poliedro
originale può essere recuperato applicando l'unione dei vincoli
\(\mathcal{C}_{P_k}\) e il prodotto cartesiano dei generatori \(\mathcal{G}_{P_k}\).

\begin{exmp}
  Consideriamo un poliedro $\mathcal{P}$ con i seguenti vincoli e generatori:
  \begin{align*}
    &\mathcal{C} = \{-x_{1} \le -1, x_{1} \le 4, -x_{2} \le -2, x_{2} \le 4\} \\
    &\mathcal{G} = \{\{(1),(2)\}, \{(1),(4)\}, \{(4),(2)\}, \{(4),(4)\}\}
  \end{align*}
  Il poliedro non ha vincoli tra le variabili $x_1$ e $x_2$. Quindi, $\mathcal{X} = \{x_1,x_2\}$
  può essere partizionato nei blocchi: $\pi_P = \{\{x_1\}, \{x_2\}\}$ con i risultanti fattori
  $P_1 = (\mathcal{C}_{P_1}, \mathcal{G}_{P_1})$ e $P_2 = (\mathcal{C}_{P_2}, \mathcal{G}_{P_2})$ dove:
  \begin{align*}
      &\mathcal{C}_{P_{1}} = \{-x_{1} \le -1, x_{1} \le 4\}  &&\mathcal{C}_{P_{2}} = \{ -x_{2} \le -2, x_{2} \le 4\} \\
      &\mathcal{G}_{P_{1}} = \{\{(1),(4)\}, \emptyset, \emptyset \} &&\mathcal{G}_{P_{2}} = \{\{(2),(4)\}, \emptyset, \emptyset \}
  \end{align*}
  Il poliedro originale può essere ricavato da $P_{1}$ e $P_{2}$ come
  P = $P_{1} \bowtie P_{2} = (\mathcal{C}_{P_{1}} \cup \mathcal{C}_{P_{2}}, \mathcal{G}_{P_{1}} \times \mathcal{G}_{P_{2}})$
\end{exmp}

L'insieme \(\mathcal{L}\) che consiste in tutte le partizioni possibili di \(\mathcal{X}\)
forma un \emph{reticolo di partizioni} \((\mathcal{L}, \sqsubseteq, \sqcup, \sqcap,
\bot, \top)\). Gli elementi \(\pi\) del reticolo sono ordinati come segue: \(\pi
\sqsubseteq \pi'\), se ogni blocco di \(\pi\) è incluso in qualche blocco di
\(\pi'\). Questo reticolo contiene anche i soliti operatori di \emph{least upper bound}
\((\sqcup)\) e \emph{greatest upper bound} \((\sqcap)\). È da notare che nel reticolo della
partizione \(\top = \{\mathcal{X}\}\) e \(\bot = \{\{x_1\}, \{x_2\}, ..., \{x_n\}\}\).

\section{Partizione ammissibile}
\label{sec:org28db91a}
Una partizione \emph{ammissibile} \(\overline{\pi}\) è tale se, dato un poliedro P, non esistono
variabili \(x_i\) e \(x_j\) in diversi blocchi di \(\pi\) relazionati da un vincolo di
P, ovvero \(\pi \sqsupseteq \pi_P\). Le partizioni ammissibili sono un
sottoinsieme chiuso superiormente del reticolo, chiameremo questo sottoinsieme
\(\mathcal{B}\). Se \(\overline{\pi} \in \mathcal{B}\) allora lo saranno anche tutte
le \(\overline{\pi}'\) tali che \(\overline{\pi}, \overline{\pi}' \in \mathcal{L}\) e
\(\overline{\pi} \sqsubseteq \overline{\pi}'\). Le partizioni ammissibili sono
dotate di elemento minimo ovvero la più fine partizione appartenente a
\(\mathcal{B}\), partizione che verrà anche considerata come la migliore. Questa
partizione minima viene calcolata come spiegato nell'\textbf{esempio 2.1.1}.

Il nostro obiettivo è quello di cercare di utilizzare sempre la partizione
ammissibile minima.
\section{Operazioni}
\label{sec:org4e53b79}
In questo paragrafo verrà spiegato l'effetto che alcune operazioni dei poliedri
generano sui fattori. Innanzitutto è fondamentalche che, nelle operazioni
binarie, i poliedri abbiano lo stesso numero di dimensioni. Per descrivere
meglio queste operazioni, è necessario prima dare una specifica di alcune
funzioni utilizzate all'interno delle prime.
\(\\\)
\(\\\)
\-\hspace{0.1cm} \textbf{Convert Constraint.} Funzione che mappa le dimensioni di un vincolo o
generatore all'interno di un fattore. La PPLite utilizza dimensioni nel range
\([0, ..., n]\) per i poliedri. Tramite la fattorizzazione è quindi necessario
tradurre gli indici esterni a quelli interni dei vari blocchi.
\(\\\)
\(\\\)
\-\hspace{0.1cm} \textbf{Least Upper Bound.} Questa funzione estrae il \emph{lub} di due partizioni.
Dall'Algoritmo 1 si può notare come sia necessario generare l'insieme delle
unioni dei due blocchi \(\pi_{\mathcal{P}}\) e \(\pi_{\mathcal{Q}}\) in
\(\overline{\pi}\). Successivamente si uniscono tra loro tutti i blocchi di
\(\overline{\pi}\) che hanno un'intersezione non vuota, calcolando
successivamente la partizione corretta.
\begin{algorithm}[H]
  \caption{Least-Upper-Bound}\label{lub}
  \begin{algorithmic}[1]
    \Function{Least-Upper-Bound}{$\pi_{\mathcal{P}}, \pi_{\mathcal{Q}}$}
    \State $\overline{\pi} := \emptyset$
    \For{\textbf{each} $\mathcal{X}_{\mathcal{P}i}$ \textbf{in} $\pi_{\mathcal{P}}$}
    \State$\mathcal{A}$:= $\emptyset$
    \For{\textbf{each} $\mathcal{X}_{\mathcal{Q}k} in \pi_{\mathcal{Q}}$}
    \If{$\mathcal{X}_{\mathcal{P}i} \cap\mathcal{X}_{\mathcal{Q}k} \ne \emptyset$}
    \State$\mathcal{A}:=\mathcal{B} \cup\mathcal{X}_{\mathcal{Q}k}$
    \EndIf
    \EndFor
    \State $\overline{\pi}$.add($\mathcal{A}$)
    \EndFor
    \While{$\exists$ coppie ($\overline{\pi}_i, \overline{\pi}_j$), $i \ne j$ \textbf{t.c.} $\overline{\pi}_i \cap \overline{\pi}_j \ne \emptyset$}
    \State $\overline{\pi}$ := $\ \{\overline{\pi}_i, \overline{\pi}_j\} \cup \{\overline{\pi}_i \cup \overline{\pi}_j\}\}$
    \EndWhile
    \Return $\overline{\pi}$
    \EndFunction
  \end{algorithmic}
\end{algorithm}
\(\\\)
\(\\\)
\-\hspace{0.1cm} \textbf{Merge.} Definito come \(\uparrow\), quando si ha l'operazione
\(\pi \uparrow \mathcal{A}\), dove \(\pi\) è una partizione di un poliedro e
\(\mathcal{A}\) è un sottoindieme delle sue variabili (non per forza connesse da
vincoli), genera una partizione \(\pi_{merge}\) tale che:

\begin{itemize}
\item \(\exists\) \(\mathcal{X}_i \in \pi_{merge} : \mathcal{A} \subseteq \mathcal{X}_i\)
\item \(\pi \sqsubseteq \pi_{merge}\)
\end{itemize}

Viene quindi generata una nuova fattorizzazione unendo i blocchi del poliedro
che hanno variabili in comune con \(\mathcal{A}\). Questa unione genera un blocco
unico \(\mathcal{D}\), tale che \(\mathcal{A} \subseteq \mathcal{B}\).

\begin{algorithm}[H]
\caption{Merge}\label{merge}
\begin{algorithmic}[1]
\Function{Merge}{$\pi, \mathcal{A}$}
\State$\pi_{\mathcal{O}} := \emptyset$
\State$\mathcal{D} := \emptyset$
\For{\textbf{each} $\mathcal{X}_{i}$ \textbf{in} $\pi$}
\If{$\mathcal{X}_{i} \cap \mathcal{A} \ne \emptyset$}
\State$\mathcal{D} := \mathcal{D} \cup \mathcal{X}_{i}$
\Else
\State$\pi_{\mathcal{O}}$.add$(\mathcal{X}_{i})$
\EndIf
\EndFor
\State$\pi_{\mathcal{O}}$.add$(\mathcal{D})$
\State\textbf{return} $\pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\-\hspace{0.1cm} \textbf{Refactor.} Questa operazione ha come argomenti un poliedro
fattorizzato e una fattorizzazione ammissibile \(\overline{\pi}\) per questo
poliedro. Non fa altro che convertire i fattori rispetto alla seconda
fattorizzazione. È importante notare che la partizione ammissibile non sarà più
fine di \(\pi_{\mathcal{P}}\), visto che i blocchi non vengono divisi bensì solo
uniti.

La refactor è un'operazione necessaria in quanto, avendo due poliedri
\(\mathcal{P}\) e \(\mathcal{Q}\) definiti sullo stesso insieme di variabili \(X =
\{x_1, x_2, ..., x_n\}\) e presi \(\overline{\pi}_{\mathcal{P}} =
\{X_{\mathcal{P}_1}, X_{\mathcal{P}_2}, ..., X_{\mathcal{P}_r}\}\),
\(\overline{\pi}_{\mathcal{Q}} = \{X_{\mathcal{Q}_1}, X_{\mathcal{Q}_2}, ...,
X_{\mathcal{Q}_s}\}\)
partizioni corrette di \(\mathcal{P}\) e \(\mathcal{Q}\) in genere abbiamo che
\(\overline{\pi}_{\mathcal{P}} \ne \overline{\pi}_{\mathcal{Q}}\). È necessario
che, come in molte operazioni comuni nell'analisi e manipolazione dei poliedri,
le dimensioni delle partizioni utilizzate siano uguali in quantità e valori. Se
si applica la fattorizzazione su poliedri aventi gli stessi blocchi non si fa
altro che calcolare il \emph{lub} (\(\overline{\pi} = \overline{\pi}_{\mathcal{P}}
\; \sqcup \; \overline{\pi}_{\mathcal{Q}}\)).

\begin{algorithm}[H]
\caption{Refactor}\label{refactor}
\begin{algorithmic}[1]
\Function{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \overline{\pi}$}
\State$\mathcal{O}, \pi_{\mathcal{O}} := \emptyset$
\For{\textbf{each} $i$ \textbf{in} $\{1,..., r\}$} \Comment{r = numero blocchi di $\pi_{\mathcal{P}}$}
\State$\mathcal{O}_{i}, \pi_{\mathcal{O}i} := \emptyset$
\For{\textbf{each} $j$ \textbf{in} $\{1,...,m\}$} \Comment{m = numero blocchi di $\overline{\pi}$}
\If{$\pi_{\mathcal{P}i} \cap \overline{\pi}_{i} \ne \emptyset$}
\State$\mathcal{O}_{i}$ := $\mathcal{O}_{j} \bowtie \mathcal{P}_{i}$
\State$\pi_{\mathcal{O}i}$ := $\pi_{\mathcal{O}i} \bowtie \pi_{\mathcal{P}i}$
\EndIf
\EndFor
\State$\mathcal{O}$.add$(\mathcal{O}_{i})$
\State$\pi_{\mathcal{O}}$.add$(\pi_{\mathcal{O}i})$
\EndFor
\State\Call{Remap-Dimensions}{$\mathcal{O}, \pi_{\mathcal{O}}, \overline{\pi}$}
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

Come spiegato precedentemente, la refactor prende in input un poliedro
fattorizzato \(\mathcal{P}\) e la sua partizione \(\pi_{\mathcal{P}}\) per
rifattorizzarlo in base al terzo parametro \(\overline{\pi}\). Non fa altro che
unire i fattori che hanno intersezione dei relativi blocchi non vuota tra
\(\pi_{\mathcal{P}}\) e \(\overline{\pi}\) e generare il blocco finale. È importante
ri-mappare le dimensioni dei fattori di output in base a quelle descritte nel
blocco di \(\overline{\pi}\).

\subsection{Inclusion Test (\(\sqsubseteq\))}
\label{sec:orgb4c984d}
Operazione necessaria per controllare se un poliedro è incluso in un altro,
disponendo di una doppia rappresentazione è possibile controllarlo se, dati due
poliedri \(\mathcal{P}\) e \(\mathcal{Q}\) tutti i generatori in
\(\mathcal{G}_{\mathcal{P}}\) soddisfano tutti i vincoli in
\(\mathcal{C}_{\mathcal{Q}}\).

Nel nostro caso e, come mostrato nell'Algoritmo 4, è stata implementata tramite
wrapper. In particolare vengono rifattorizzati i poliedri con il \emph{lub}
\(\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}\) e successivamente viene applicata
l'\emph{inclusion} in ordine su ogni coppia di fattori: il test avrà successo se
tutti i test ritornano \emph{True}.

\begin{algorithm}[H]
\caption{Inclusion Test}\label{inclusion test}
\begin{algorithmic}[1]
\Function{Inclusion}{$\mathcal{P},\pi_{\mathcal{P}},\mathcal{Q},\pi_{\mathcal{Q}}$}
\State$\overline{\pi}$ := \Call{Leas-Upper-Bound}{$\pi_{\mathcal{P}},\pi_{\mathcal{Q}}$}
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \overline{\pi}$}
\State$\mathcal{Q}'$ := \Call{Refactor}{$\mathcal{Q}, \pi_{\mathcal{Q}}, \overline{\pi}$}
\For{\textbf{each} $k$ \textbf{in} $\{1,...,r\}$} \Comment{r = numero di blocchi in $\overline{\pi}$}
\If{$\mathcal{P}'_{k}$ non include $\mathcal{Q}'_{k}$ }
\State\Return\textit{False}
\EndIf
\EndFor
\State\Return\textit{True}
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Join (\(\sqcup\))}
\label{sec:org1e42a41}
Tramite la doppia reppresentazione, i generatori \(\mathcal{G}_{\mathcal{O}}\)
dove \(\mathcal{O}\) è il risultato del \emph{join}, sono semplicemente l'unione dei
generatori dei poliedri presi in input dalla funzione, ovvero
\(\mathcal{G}_{\mathcal{O}}\) = \(\mathcal{G}_{\mathcal{P}} \cup
\mathcal{G}_{\mathcal{Q}}\). I vincoli \(\mathcal{C}_{\mathcal{O}}\) sono ottenuti
aggiungendo incrementalmente i generatori di \(\mathcal{G}_{\mathcal{Q}}\) al
poliedro definito da \(\mathcal{C}_{\mathcal{P}}\).

\begin{algorithm}[H]
\caption{Join}\label{join}
\begin{algorithmic}[1]
\Function{Join}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{O}, \pi_{\mathcal{O}}$}
\If{\Call{is\_empty}{$\mathcal{P}$}}
\State$\mathcal{O}, \pi_{\mathcal{O}}$ := $\mathcal{Q}, \pi_{\mathcal{Q}}$
\ElsIf{\Call{is\_empty}{$\mathcal{Q}$}}
\State$\mathcal{O}, \pi_{\mathcal{O}}$ := $\mathcal{P}, \pi_{\mathcal{P}}$
\Else
\State$\mathcal{O}, \pi_{\mathcal{O}}$ := \Call{Join-Poly}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{O}, \pi_{\mathcal{O}}$}
\EndIf
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

Avendo un sistema di poliedri fattorizzati, è necessario per prima cosa
rifattorizzare \(\mathcal{P}\) e \(\mathcal{Q}\) utilizzando il loro \emph{lub}. Per ogni
coppia di fattori \((\mathcal{P}'_{i}, \mathcal{Q}'_{i})\) uguali, se ne aggiunge
uno con il rispettivo blocco \(\overline{\pi}_i\) al risultato. Se invece i due
fattori risultano diversi, ognuno viene unito a un fattore comune
\((\mathcal{P}'_{i}, \mathcal{Q}'_{i})\) e successivamente si calcola la \emph{join} di
questi due fattori e si inserisce insieme al rispettivo blocco nel poliedro di
output.

Un caso speciale è stato assegnato ai poliedri \emph{vuoti}. Dati \(\mathcal{P}\) come
poliedro \emph{vuoto} e \(\mathcal{Q}\) un poliedro generico allora \(\mathcal{Q} \cup
\mathcal{P}\) = \(\mathcal{Q}\) e anche \(\mathcal{P} \cup
\mathcal{Q}\) = \(\mathcal{Q}\).

Se invece \(\overline{\pi} = \overline{\pi}_{\mathcal{P}} \sqcup
\overline{\pi}_{\mathcal{Q}}\) e \(\mathcal{U} = \{\mathcal{X}_k \: | \: \mathcal{P}
= \mathcal{Q}, \mathcal{X}_k \in \overline{\pi} \}\) allora la partizione
ammissibile, in questo caso, sarà uguale a:

\begin{align*}
\overline{\pi}_{\mathcal{P} \sqcup \mathcal{Q}} = \mathcal{U} \cup \bigcup_{\mathcal{T} \in \overline{\pi} \backslash \mathcal{U}} \mathcal{T}
\end{align*}

\begin{algorithm}[H]
\caption{Join-Poly}\label{join-poly}
\begin{algorithmic}[1]
\Function{Join-Poly}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{O}, \pi_{\mathcal{O}}$}
\State$\overline{\pi}$ := $\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}$
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P, \pi_{\mathcal{P}}, \overline{\pi}}$}
\State$\mathcal{Q}'$ := \Call{Refactor}{$\mathcal{Q, \pi_{\mathcal{Q}}, \overline{\pi}}$}
\For{\textbf{each} $i$ \textbf{in} $\{0,...,|\mathcal{P}'|\}$}
\If{$\mathcal{P}'_i = \mathcal{Q}'_i$}
\State$\mathcal{O}$.add$(\mathcal{P}'_{i})$
\State$\pi_{\mathcal{O}}$.add$(\mathcal{X}'_{i})$
\Else
\State$\mathcal{X}_{\mathcal{T}}$ := $\mathcal{X}_{\mathcal{T}} \cup \overline{\pi}_{i}$
\State$\mathcal{P}_{\mathcal{T}}$ := $\mathcal{P}_{\mathcal{T}} \bowtie \mathcal{P}'_{i}$
\State$\mathcal{Q}_{\mathcal{T}}$ := $\mathcal{Q}_{\mathcal{T}} \bowtie \mathcal{Q}'_{i}$
\EndIf
\EndFor
\State$\mathcal{P}_{\mathcal{T}}$ := $\mathcal{P}_{\mathcal{T}} \sqcap \mathcal{Q}_{\mathcal{T}}$
\State$\pi_{\mathcal{O}}$.add$(\mathcal{X}_{\mathcal{T}})$
\State$\mathcal{O}$.add$(\mathcal{P}_{\mathcal{T}})$
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Meet (\(\sqcap\))}
\label{sec:org5bef6c3}
Per la doppia rappresentazione, \(\mathcal{P} \sqcap \mathcal{Q}\) genera un
poliedro i cui vincoli \(\mathcal{C}_{\mathcal{P} \sqcap \mathcal{Q}}\) sono
risultati dall'unione di \(\mathcal{C}_{\mathcal{P}}\) e
\(\mathcal{C}_{\mathcal{Q}}\), mentre \(\mathcal{G}_{\mathcal{P} \sqcap
\mathcal{Q}}\) si ottiene aggiungendo incrementalmente i vincoli di
\(\mathcal{C}_{\mathcal{Q}}\) al poliedro \(\mathcal{P}\). Se \(\mathcal{P} \sqcap
\mathcal{Q}\) risulta non soddisfacibile allora \(\mathcal{P} \sqcap \mathcal{Q} =
\bot\) e \(\mathcal{G}_{\mathcal{P} \sqcap \mathcal{Q}} = \emptyset\).

Per quanto riguarda i poliedri fattorizzati è necessario generare
\(\overline{\pi} = \overline{\pi}_{\mathcal{P}} \sqcap
\overline{\pi}_{\mathcal{Q}}\) e rifattorizzare i due poliedri \(\mathcal{P}\) e
\(\mathcal{Q}\) tramite essa, generando quindi \(\mathcal{P}'\) e \(\mathcal{Q}'\).
Per tutte le \(r\) coppie di fattori \(\mathcal{P}'_i\) e \(\mathcal{Q}'_i\), se
sono uguali aggiungo \(\mathcal{P}'_i\) con il rispettivo blocco al poliedro di
output \(\mathcal{O}\), altrimenti creo un fattore \(\mathcal{F} = \mathcal{P}'_i
\sqcap \mathcal{Q}'_i\). Se \(\mathcal{F}\) dovesse risultare vuoto, allora il
risultato dell'intera operazione di \emph{meet} sarebbe un poliedro \(\bot\). Se al
contrario non fosse vuoto, aggiungo \(\mathcal{F}\) a \(\mathcal{O}\) per poi
riprender il ciclo fino all'esaurimento dei fattori e ritornando infine
\(\mathcal{O}\) e il suo blocco (rappresentato dal \emph{lub} di \(\pi_{\mathcal{P}}\) e
\(\pi_{\mathcal{Q}}\)) come risultato. \(\overline{\pi}_{\mathcal{P} \sqcap
\mathcal{Q}} = \pi_{\mathcal{P}} \sqcap \pi_{\mathcal{Q}}\) è una partizione
ammissibile se \(\mathcal{P} \sqcap \mathcal{Q} \ne \bot\), altrimenti \(\bot\) è
ammissibile.

\begin{algorithm}[H]
\caption{Meet}\label{meet}
\begin{algorithmic}[1]
\Function{Meet}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{Q}, \pi_{\mathcal{Q}}$}
\State$\overline{\pi}$ := $\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}$
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \overline{\pi}$}
\State$\mathcal{Q}'$ := \Call{Refactor}{$\mathcal{Q}, \pi_{\mathcal{Q}}, \overline{\pi}$}
\State$\mathcal{O}$ := $\emptyset$
\For{\textbf{each} $i$ \textbf{in} $\{1,...,r\}$}\Comment{r = numero di blocchi in $\overline{\pi}$}
\If{$\mathcal{P}'_i = \mathcal{Q}'_i$}
\State$\mathcal{O}$.add$(\mathcal{P}'_i)$
\Else
\State$\mathcal{F}$ := $\mathcal{P}'_{i} \bowtie \mathcal{Q}'_{i}$
\If{\Call{is\_empty}{$\mathcal{F}$}}
\State\Return$\bot, \bot$
\EndIf
\State$\mathcal{O}$.add$(\mathcal{F})$
\EndIf
\EndFor
\State$\pi_{\mathcal{O}}$ := $\overline{\pi}$
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}


\subsection{Conditional}
\label{sec:org8a655f6}
Questa operazione viene utilizzata per aggiungere nuovi vincoli tra le variabili
di un poliedro. Tramite la doppia rappresentazione è possibile aggiungendo un
vincolo arbitrario \(c\) all'insieme \(\mathcal{C}_{\mathcal{P}}\). Se dopo
l'inserimento il sistema di vincoli risulta insoddisfacibile allora il poliedro
diventa vuoto. Il sistema di generatori è, come sempre, ricavato dall'aggiunta
incrementale del vincolo \(c\) nel poliedro attraverso la conversione.

Utilizzando poliedri fattorizzati è necessare ricavare il blocco \(\mathcal{B}\) che contiene le
variabili utilizzate nel vincolo, rifattorizzando \(\mathcal{P}\) con
\(\overline{\pi}_{\mathcal{P}} \uparrow \mathcal{B}\) si genera \(\mathcal{P}'\).
Successivamente bisogna prendere il fattore relativo contenente le variabili di
\(\mathcal{B}\), convertire il vincolo con le dimensioni \emph{interne} del fattore e
aggiungerlo a quest'ultimo utilizzando un'operazione per normali poliedri. Si
controlla, infine, che il sistema di vincoli sia ancora soddisfacibile e, in
caso negativo i blocchi e i fattori in \(\bot\) vengono modificati e il poliedro
si rende \emph{vuoto}. È importante far notare che, dato \(\mathcal{O}\) un poliedro
risultante dall'aggiunta di un vincolo, \(\overline{\pi}_{\mathcal{O}} = \overline{\pi}_{\mathcal{P}}
\uparrow \mathcal{B}\) è ammissibile se \(\mathcal{O} \ne \bot\), altrimenti
\(\overline{\pi}_{\mathcal{O}} = \bot\).

\begin{algorithm}[H]
\caption{Conditional}\label{conditional}
\begin{algorithmic}[1]
\Function{Conditional}{$con$}
\State$\mathcal{B}$ := \Call{extract\_block}{$\mathcal{P}$, $\pi_{\mathcal{P}}$, \textit{con}}
\State$\overline{\pi}$ := $\pi_{\mathcal{P}} \uparrow \mathcal{B}$
\State$\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \overline{\pi}$}
\For{\textbf{each} $i$ \textbf{in} $\{1,...,r\}$}\Comment{r = numero di blocchi in $\overline{\pi}$}
\If{$\mathcal{B} \cap \overline{\pi}_i \ne \emptyset$}
\State$con_{int}$ := \Call{convert\_con}{$\overline{\pi}_i$, \textit{con}}
\State$\mathcal{F}$ := \Call{add\_con}{$\mathcal{P}'_i, con_{int}$}
\State$\mathcal{O}$.add$(\mathcal{F})$
\If{\Call{is\_empty}{$\mathcal{O_{i}}$}}
\State\Return$\bot, \bot$
\EndIf
\State$\mathcal{O}$.add$(\mathcal{P'_i})$
\EndIf
\EndFor
\State$\pi_{\mathcal{O}}$ := $\overline{\pi}$
\State\Return$\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Assignment}
\label{sec:org911e96a}
Per quanto riguarda il dominio dei poliedri fattorizzati, l'operazione di
\emph{assignment} è molto simile alla \emph{conditional}. Dopo aver estratto il blocco
\(\mathcal{B}\) che indica le variabili utilizzate nell'espressione lineare, si
fattorizza il poliedro \(\mathcal{P}\) con \(\overline{\pi}_{\mathcal{P}} =
\pi_{\mathcal{P}} \uparrow \mathcal{B}\) ottenendo \(\mathcal{P}'\),
successivamente si prende il blocco con le variabili di \(\mathcal{B}\) e si
applica al relativo fattore un \emph{assignment} come per i poliedri non
fattorizzati, rimappando correttamente le variabili esterne rispetto a quelle
interne al fattore. La partizione ammissibile per un poliedro risultante da
questa operazione è \(\overline{\pi}_{\mathcal{P}} \uparrow \mathcal{B}\).

\begin{algorithm}[H]
\caption{Assignment}\label{assignment}
\begin{algorithmic}[1]
\Function{Assignment}{$\mathcal{P}$, $\pi_{\mathcal{P}}, stmt$}
\State let $stmt = (x_{i} = ax + \epsilon) $
\State$\mathcal{B}$ := \Call{extract\_block}{$stmt$}
\State$\overline{\pi}$ := $\pi_{\mathcal{P}} \uparrow \mathcal{B}$
\State$\mathcal{P}'$ := \Call{refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \overline{\pi}$}
\For{\textbf{each} $i$ \textbf{in} $\{1,...,r\}$}\Comment{$r = |\mathcal{P}|$}
\If{$\overline{\pi}_i \subseteq \mathcal{B}$}
\State$stmt_{int}$ := \Call{convert}{$\overline{\pi}, stmt$}
\State$\mathcal{F}$ := \Call{assignment}{$\mathcal{P}'_i, stmt_{int}$}\Comment{Poliedri non fattorizzati}
\State $\mathcal{O}$.add$(\mathcal{F})$
\If{$\mathcal{P}'_i$ := $\emptyset$}
\State\Return$\bot,\bot$
\EndIf
\Else
\State $\mathcal{O}$.add$(\mathcal{P}'_i)$
\EndIf
\EndFor
\State\Return $\mathcal{O}, \overline{\pi}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Widening (\(\nabla\))}
\label{sec:orgd447808}
Per la doppia rappresentazione, l'operatore di \emph{widening} necessità come
parametri i generatori e i vincoli di \(\mathcal{P}\) e i vincolo di
\(\mathcal{Q}\). Il risultato dell'operazione \(\mathcal{P} \nabla
\mathcal{Q}\) conterrà i vincoli \(\mathcal{C}_{\mathcal{Q}}\) che sono presenti in
\(\mathcal{C}_{\mathcal{P}}\) o che possono sostituirne un vincolo senza cambiare
\(\mathcal{P}\).

Per implementarlo è necessario effettuare uan rifattorizzazione \(\mathcal{P}'\)
del primo argomento \(\mathcal{P}\) con \(\overline{\pi} = \pi_{\mathcal{P}} \sqcup
\pi_{\mathcal{Q}}\), mentre non è necessario rifattorizzare il secondo argomento.
Successivamente, per ogni fattore \(\mathcal{Q}_i\) del secondo argomento si
individua il fattore corrispondente \(\mathcal{P}'_k\) in \(\mathcal{P}'\) e si
procede a individuare l'insieme \(\mathcal{C}_{\mathcal{O}_i}\) di vincoli di
\(\mathcal{Q}_i\) che sono \emph{stabili} rispetto a \(\mathcal{P}'_k\): questi vincoli
costituiscono il risultato del widening rispetto a quel fattore. È possibile,
come caso speciale, che se \(\pi_{\mathcal{P}'_k} = \pi_{\mathcal{Q}_i}\), allora è
possibile applicare direttamente l'operatore di widening per poliedri non
fattorizzati.

\begin{algorithm}[H]
\caption{Meet}\label{meet}
\begin{algorithmic}[1]
\Function{Widenind}{$\mathcal{P}, \pi_{\mathcal{P}}, \mathcal{Q}, \pi_{\mathcal{Q}}$}
\State $\overline{\pi}$ := $\pi_{\mathcal{P}} \sqcup \pi_{\mathcal{Q}}$
\State $\mathcal{P}'$ := \Call{Refactor}{$\mathcal{P}, \pi_{\mathcal{P}}, \overline{\pi}$}
\State $\mathcal{O}$ := $\emptyset$
\For{\textbf{each} $i$ \textbf{in} $\{1,...,r\}$}\Comment{$q$ = numero di blocchi in $\pi_{\mathcal{Q}}$}
\State $\mathcal{C}_{\mathcal{O}_i}$ := $\emptyset$
\State $k$ := $j$, t.c. $\mathcal{X}_{\mathcal{Q}_i} \subseteq \mathcal{X}_j, \mathcal{X}_j \in \overline{\pi}$
\If{$\overline{\pi}_k = \overline{\pi}_{\mathcal{Q}_i}$}
\State $\mathcal{Q}_i$ := \Call{Widening}{$\mathcal{P}'_k, \mathcal{Q}_i$}
\Else
\State $\mathcal{C}_{\mathcal{O}_i}$ := \Call{select\_stable\_con}{$\mathcal{C}_{\mathcal{Q}_i}, \mathcal{P}'_k$}
\State $\mathcal{Q}_i$ := \Call{new\_factor}{$\mathcal{C}_{\mathcal{O}_i}$}
\EndIf
\State $\mathcal{O}$.add$(\mathcal{O}_i)$
\EndFor
\State\Return $\mathcal{O}, \pi_{\mathcal{O}}$
\EndFunction
\end{algorithmic}
\end{algorithm}



\chapter{Implementazione}
\label{sec:org39d7878}
Questo capitolo tratterà dell'implementazione effettiva dei poliedri
fattorizzati e di alcune loro operazioni. La struttura è stata basata su di un
\emph{wrapper} preesistente nella \emph{PPlite} mentre alcune delle implementazioni sono
state attuate effettuando un porting dalla libreria \emph{PPL}. La maggiorparte delle
operazioni sono state sviluppate come un wrapper per la \emph{PPLite}, difatti le
operazioni sui singoli poliedri sono gestite da essa. Lo scopo principale è
quello di inserirsi all'interno dell'analisi statica e utilizzare i poliedri
fattorizzati se e quando vengono generati poliedri che implicano un alto
overhead per essere gestiti, in questo caso i suddetti poliedri vengono
fattorizzati in maniera tale da diminuire il carico computazionale.
L'implementazione è stata sviluppata interamente in \emph{C++11} con l'obiettivo di
utilizzare i metodi della \emph{Standard Library} così da incrementare la leggibilità
del codice. L'efficienza non è stata presa come obiettivo principale durante lo
sviluppo, dando importanza alla correttezza e alla leggibilità del codice.

\section{\texttt{F\_Poly}}
\label{sec:org3fd096e}
La classe dove sono compresi gran parte dei medoti è \texttt{F\_Poly}. È stata
definita nel file \texttt{F\_Poly.hh} dove sono presenti 92 metodi pubblici e 14 metodi
privati.

Per la costruzione/distruzione degli oggetti è stata seguita la
\emph{Rule of Five}, quindi abbiamo:

\begin{itemize}
\item Un costruttore esplicito, un costruttore per copia, un costruttore per spostamento
\item Operazioni di assegnamento per copia e per spostamento;
\item Un distruttore;
\end{itemize}

Abbiamo anche:

\begin{itemize}
\item Un metodo \texttt{check\_inv()} per controllare che le invarianti di classe non siano
state violate;
\item Le operazioni principali descritte nel Capitolo 2.3;
\item Funzioni di appoggio per gestire il poliedro;
\end{itemize}

Sono inoltre presenti delle stutture dati per la gestione dei fattori:

\begin{itemize}
\item \texttt{Block}: un \texttt{std::vector}\footnote{\texttt{template<class T, class Allocator = std::allocator<T>> class vector;}} di \texttt{dim\_type} che rappresenta un blocco \(\mathcal{X}_i\) che
contiene alcune dimensioni del poliedro;
\item \texttt{Blocks}: un \texttt{std::vector} di \texttt{Block} che esprime le partizioni del poliedro;
\item \texttt{Factor}: un fattore è un poliedro, difatti \texttt{Factor} è un alias per oggetti di tipo \texttt{Poly};
\item \texttt{Factors}: un \texttt{std::vector} di \texttt{Factor};
\end{itemize}

Sono inoltre presenti tre variabili:

\begin{itemize}
\item \texttt{dim\_type dim}: indicante le dimensioni del poliedro
\item \texttt{Topol topol}: indicante la topologia del poliedro
\item \texttt{bool is\_empty}: indicante se il poliedro è vuoto o no
\end{itemize}

\subsection{\texttt{check\_inv()}}
\label{sec:orga8fdb5e}
Il metodo menzionato contiene tutti i controlli necessari per verificare che
l'invariante di classe non sia stata violata, e che quindi il poliedro su cui si
sta lavorando è in condizioni di correttezza. Le invarianti di classe che devono
essere rispettate sono le seguenti:

\begin{itemize}
\item La dimensione minima del poliedro deve essere \(\ge 0\)
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
if (dim < 0) {
  reason = "F_Poly broken: invalid space dimension";
  maybe_dump();
  return false;
}
\end{lstlisting}
\item Se il poliedro è vuoto, i fattori e i blocchi devono essere anch'essi vuoti
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
if (is_empty()) {
  if (!(factors.empty() && blocks.empty())) {
    reason = "F_Poly broken: empty polyhedron has factors";
    maybe_dump();
    return false;
  }
  // No other check for an empty polyhedron.
  return true;
}
\end{lstlisting}
\item Il numero di blocchi deve essere uguale al numero di fattori
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
if (factors.size() != blocks.size()) {
  reason = "F_Poly broken: #factors != #blocks";
  maybe_dump();
  return false;
}
\end{lstlisting}
\item La cardinalità dei blocchi deve essere uguale a \texttt{dim}
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
dim_type dim_ = 0;
for (const auto& block : blocks)
  dim_ += block.size();
if (dim != dim_) {
  reason = "F_Poly broken: space dimension mismatch";
  maybe_dump();
  return false;
}
\end{lstlisting}
\item Le dimensioni di un fattore devono essere uguali alle dimensioni del blocco
che lo rappresenta
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
// Each factor space dim should match its block.
for (dim_type i = 0; i < num_rows(factors); ++i)
  if (factors[i].space_dim() != num_rows(blocks[i])) {
    reason = "F_Poly broken: factor vs block space dim mismatch";
    maybe_dump();
    return false;
  }
\end{lstlisting}
\item Nessun fattore deve essere vuoto
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
if (std::any_of(factors.begin(), factors.end(),
                std::mem_fn(&Poly::is_empty))) {
  reason = "F_Poly broken: empty factor";
  maybe_dump();
  return false;
}
\end{lstlisting}
\item Ogni dimensione dello spazio deve apparire una e una volta soltanto nei
blocchi e non devono esserci blocchi vuoti
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
std::vector<bool> dims(dim, false);
for (const auto& block : blocks) {
  if (block.size() == 0) {
    reason = "F_Poly broken: found empty block";
    maybe_dump();
    return false;
  }
  for (const auto d : block) {
    if (d < 0 || d >= dim) {
      reason = "F_Poly broken: block contains an illegal
                space dim";
      maybe_dump();
      return false;
    }
    if (dims[d]) {
      reason = "F_Poly broken: repeated space dim in blocks";
      maybe_dump();
      return false;
    }
    dims[d] = true;
  }
}
\end{lstlisting}
\item Ogni dimensione dello spazio deve essere presente in un blocco
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
if (std::find(dims.begin(), dims.end(), false) != dims.end()) {
  reason = "F_Poly broken: a space dim is missing from blocks";
  maybe_dump();
  return false;
}
\end{lstlisting}
\end{itemize}

\section{Operazione di base}
\label{sec:org5c3a749}
Durante la lettura di questo paragrafo, sarà palese la diversa notazione
utilizzata rispetto a \cite{fastpoly}: questo perché, per motivi di
compatibilità e trasparenza si è deciso di implementare le varie operazioni
utilizzando i nomi con il loro corrispettivo della \emph{PPLite}.

Inizialmente il lavoro si è basato sul attuare un porting dai poliedri
fattorizzati implementati nella \emph{PPL}, successivamente il focus è stato
nell'adattarli al meglio alle strutture utilizzate nella PPLite, permettendo una
semplificazione nella codifica e nel testing. Il principio base
sotto all'implementazione di alcune operazioni è stato quello di preparare
strutturalmente i poliedri fattorizzati in maniera tale da rendere possibile
richiamare le varie operazioni.

Diverse sono le funzioni più significative definite all'interno di \texttt{F\_Poly.hh}:

\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
static Factors refactor(const Factors& f,
                        const Blocks& b1, const Blocks& b2);
static Blocks least_upper_bound(const Blocks& b1, const Blocks& b2);
static Blocks merge(const Blocks& b, const Block& added);
void join(const Factors& f, const Blocks& b);
void join(const F_Poly& f);
void affine_image(Var var, const Linear_Expr& expr,
                  const Integer& inhomo = Integer::zero(),
                  const Integer& den = Integer::one());


void affine_preimage(Var var, const Linear_Expr& expr,
                     const Integer& inhomo = Integer::zero(),
                     const Integer& den = Integer::one());
void add_con(const Con& c);
void add_gen(const Gen& c);
bool inclusion(const Factors& f, const Blocks& b) const;
\end{lstlisting}

\subsection{\texttt{refactor}}
\label{sec:org156c306}
La semantica rimane invariata invariata rispetto a quanto descritto
nell'Algoritmo \ref{refactor}. Per la \emph{join} \((\bowtie)\) tra i fattori è stata
utilizzata la \texttt{concatenate\_assign()} della PPlite, una funzione omonima, per
quanto riguarda il join dei blocchi, è stata implementata utilizzando
\texttt{std::insert}\footnote{\texttt{template <class InputIt>
iterator insert(const\_iterator pos, InputIt first, InputIt last);}}. E importante notare che questa operazione sia
ammissibile in quanto non c'è alcuna possibilità di dimensioni doppie
all'interno dei blocchi interessati.

\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
Blocks bs(bs2.size());
  Factors res(bs.size(), Factor(0, Spec_Elem::UNIVERSE));
  for (dim_type i = 0; i != num_rows(bs1); ++i)
    for (dim_type j = 0; j != num_rows(bs2); ++j) {
      if (detail::are_disjoint(bs1[i], bs2[j]))
        continue;
      res[j].concatenate_assign(fs[i]);
      concatenate_assign(bs[j], bs1[i]);
    }
\end{lstlisting}

Per rimappare le dimensioni in maniera corretta viene utilizzata la funzione
\texttt{map\_space\_dims()}, che prende come argomento un oggetto di tipo \texttt{Dims} che
viene riempito delle varie dimensioni dei blocchi che saranno rimappati in base
all'indice in cui si trovano.

\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
// Remap those factors res[i] s.t. bs[i] != bs2[i]
  for (dim_type i = 0; i != num_rows(bs2); ++i) {
    const auto& b = bs[i];
    const auto& b2 = bs2[i];
    assert(b.size() == b2.size());
    if (b == b2)
      continue;
    Dims pf(b.size());
    for (auto j = b.size(); j-- > 0; )
      pf[b[j]] = b2[j];
    res[i].map_space_dims(pf);
  }
  return res;
\end{lstlisting}

Il metodo \texttt{are\_disjoint(const Block\& b1, const Block\& b2)} viene utilizzato per
vedere se due blocchi sono uguali.

\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
inline bool
are_disjoint(const Block& b1, const Block& b2) {
  return std::find_first_of(b1.begin(), b1.end(),
                            b2.begin(), b2.end()) == b1.end();
}
\end{lstlisting}

Utilizza \texttt{std::find\_first\_of}\footnote{\texttt{template <class InputIt, class ForwardIt>
InputIt find\_first\_of(InputIt first, InputIt last, ForwardIt s\_first, ForwardIt s\_last);}} e ritorna falso se trova un elemento che è
presente in un insieme e non in un altro.

\subsection{\texttt{least\_upper\_bound}}
\label{sec:orgb256790}
L'implementazione di questo metodo non è stata menzionata in \cite{fastpoly} ma
ne è stato solo descritto l'aspetto matematico. In termini più pratici questa
operazione prende due parametri \texttt{const Blocks\& b1, const Blocks\& b2} e,
inizialmente, crea un blocco \texttt{lub} che sarà composto dalle dimensioni non in
comune tra \texttt{b1} e \texttt{b2}:

\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
Blocks lub; dim_type i = 0;
bool first = true;

for (const auto &bl1 : b1)
  for (const auto &bl2 : b2)
    if (!detail::are_disjoint(bl1, bl2)) {
      if (first) {
        lub.push_back(bl2);
        first = false;
      }
      else {
        lub[i] = block_union(lub[i], bl2);
      }
  ++i;
  first = true;
}
\end{lstlisting}

Successivamente si itera su \texttt{lub} per unire i blocchi che presentavano
dimensioni comuni fino a costruire la partizione \texttt{lub}.

\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
for (auto it1 = lub.begin(); it1 != lub.end(); ++it1)
  for (auto it2 = it1 + 1; it2 != lub.end(); ++it2)
    if (!detail::are_disjoint(*it1, *it2)) {
      *it1 = block_union(*it1, *it2);
      lub.erase(it2);
      --it2;
    }
\end{lstlisting}

Per unire i blocchi è stata utilizzata al funzione \texttt{block\_union(const Block\& b1,
const Block\& b2)} che permette di unire i blocchi ed evitare che si vengano a
creare dimensioni doppie.

\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
F_Poly::Block
F_Poly::block_union(const Block& b1, const Block& b2) {
  Block out(b1);
  bool add = true;
  for (const auto dim2 : b2) {
    for (const auto dim1 : b1)
      if (dim1 == dim2) {
        add = false;
        break;
      }
    if (add)
      out.push_back(dim2);
    else
      add = true;
  }
  return out;
}
\end{lstlisting}

\subsection{\texttt{add\_con}}
\label{sec:org8bca510}
Il metodo \texttt{add\_con} non è altro che l'implementazione dell'Algoritmo
\ref{conditional}. Per poter sviluppare questa operazione sono necessare due diverse
funzioni helper oltre a \texttt{refactor} e \texttt{merge}:

\begin{itemize}
\item \texttt{extract\_block()}: una funzione che, preso un vincolo, restituisce il blocco
contenente tutte le variabili utilizzate in esso:
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
inline Block
extract_block(const Linear_Expr& e) {
  Block var_block;
  for (dim_type i = 0; i != e.space_dim(); ++i)
    if (e.get(Var(i)) != 0)
      var_block.push_back(i);
  return var_block;
}
\end{lstlisting}
non facciamo altro che iterare una \texttt{Linear\_Expr} inserendo tutte le variabili
presenti in quest'ultima in un \texttt{std::vector}.
\item \texttt{convert}: è una funzione che permette di mappare le dimensioni di un vincolo.
Definendo come \emph{esterne} le dimensioni del poliedro nella sua interezza e
\emph{interne} quelle di un suo fattore, questo metodo effettua la traduzione da
vincolo esterno a vincolo interno in base al blocco che viene passato.
\end{itemize}

\subsection{\texttt{affine\_image} e \texttt{affine\_preimage}}
\label{sec:orga5b4206}
Questa funzione è l'implementazione dell'operazione \emph{assignment} vista
nell'Algoritmo \ref{assignment}. A differenza di quest'ultimo, per rimanere
coerenti con le definizioni della PPLite, la funzione prende in input:

\begin{itemize}
\item Una variabile \texttt{var} di tipo \texttt{Var};
\item Un'espressione lineare \texttt{expr} di tipo \texttt{Linear\_Expr};
\item Un intero \texttt{inhomo} di tipo \texttt{Integer} che rappresenta l'\emph{inhomogeneus term};
\item Un intero \texttt{den} di tipo \texttt{Integer} che rappresenta il \emph{denominatore}.
\end{itemize}

Questi parametri formeranno lo statement \(var = \frac{expr}{den} + inhomo\)
equivalente a \(x_i = ax + \epsilon\) dell'Algoritmo \ref{assignment}. Le uniche
differenze con lo pseudocodice sono che è necessario convertire sia \texttt{var} che
\texttt{expr} in base al blocco corrispondente. Una volta convertite non si fa altro
che chiamare la \texttt{affine\_image} della PPLite per ogni fattore.


\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
void
F_Poly::affine_image(Var var, const Linear_Expr& expr,
                     const Integer& inhomo, const Integer& den) {
  Block b = detail::extract_block(expr);
  detail::add_var(b, var);
  Blocks bs_out = merge(blocks, b);
  factors = refactor(factors, blocks, bs_out);
  blocks = bs_out;
  for (dim_type i = 0; i < num_rows(factors); ++i) {
    if (detail::are_disjoint(b, blocks[i]))
      break;
    Var v_int = detail::convert(var, blocks[i]);
    Linear_Expr le_int = detail::convert(expr, blocks[i]);
    factors[i].affine_image(v_int, le_int, inhomo, den);
    if (factors[i].is_empty())
      set_empty();
  }
}
\end{lstlisting}

La funzione \texttt{affine\_preimage} è identica a quella appena descritta, con l'unica
differenza di chiamare la \texttt{affine\_preimage} della PPLite per ogni fattore.

\section{Altre operazioni}
\label{sec:org1bec9ef}
Oltre alle operazioni descritte in \cite{fastpoly} ne sono state aggiunte altre
per rendere più completa la classe. Tutte le operazioni descritte
successivamente non sono altro che il corrispettivo sui poliedri fattorizzati di
metodi omonimi presenti nella PPLite.

\subsection{\texttt{add\_space\_dims} e \texttt{remove\_space\_dims}}
\label{sec:orgea63e39}
Funzioni che permettono l'aggiunta e la rimozione di dimensioni del poliedro, ne
sono state implementate tre versioni:

\begin{itemize}
\item \texttt{add\_space\_dims}: permette di aggiungere \(n\) (con \(n\) parametro della
funzione) dimensioni al poliedro.
Quest'ultimo viene incorporato nel nuovo spazio vettoriale. Avendo dei fattori
implica che per ogni dimensione aggiunta deve essere aggiunto un nuovo blocco
singoletto contenente la nuova dimensione e un rispettivo fattore \emph{universo}
di dimensione \(1\). È presente anche un parametro \texttt{bool project} (settato a
\texttt{false} di default) che permette, se passato come \texttt{true}, di non incorporare il
poliedro nel nuovo spazio vettoriale. Difatti, per ogni dimensione aggiunta
viene creato un blocco singoletto che contiene la dimensione \texttt{dim} del
poliedro, mentre il fattore viene creato da un sistema di vincoli che indica
che la sua unica dimensione è vincolata ad assumere il valore 0:
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
void
F_Poly::add_space_dims(dim_type m, bool project) {
  assert(m >= 0);
  if (m == 0)
    return;
  if (is_empty()) {
    dim += m;
    return;
  }
  Factor f(1, Spec_Elem::UNIVERSE, topology());
  if (project)
    f.add_con(Var(0) == 0);
  factors.insert(factors.end(), m, f);
  for (dim_type i = 0; i != m; ++i) {
    blocks.emplace_back(1, dim);
    ++dim;
  }
}
\end{lstlisting}
\item \texttt{remove\_space\_dim}: permette di rimuovere una dimensione dal poliedro. Il
problema principale è che, rimuovendo una dimensione, è necessario
riorganizzare i blocchi in modo tale da essere uniformati all'insieme
\(\{1,...,dim\}\). Questa operazione è riservata a una funzione chiamata
\texttt{reduce\_blocks}:
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
void
F_Poly::remove_space_dim(const dim_type v) {
  for (dim_type i = 0; i < num_rows(blocks); ++i)
    for (dim_type j = 0; j < num_rows(blocks[i]); ++j)
      if (v == blocks[i][j]) {
        if (num_rows(blocks[i]) == 1) {
          blocks.erase(blocks.begin() + i);
          factors.erase(factors.begin() + i);
          reduce_blocks(blocks, v);
        }
        else {
          blocks[i].erase(blocks[i].begin() + j);
          factors[i].remove_space_dim(Var(v));
          reduce_blocks(blocks, v);
        }
        --dim;
        return;
      }
}
\end{lstlisting}
È presente anche la versione \texttt{remove\_space\_dims(const Index\_Set\& vars)} che
permette di rimuovere tutte le dimensioni presenti dentro \texttt{vars}.
\item \texttt{remove\_higher\_space\_dims}: la sua implementazione utilizza la funzione
precedente e non fa altro che rimuovere le \(n\) dimensioni (con \(n\) parametro
della funzione) più grandi del poliedro:
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
void
F_Poly::remove_higher_space_dims(dim_type new_dim) {
  if (is_empty()) {
    dim = new_dim;
    return;
  }
  for (dim_type i = space_dim(); i-- > new_dim; )
    remove_space_dim(i);
}
\end{lstlisting}
\end{itemize}

\subsection{\texttt{add\_con} e \texttt{add\_gen}}
\label{sec:org255e545}
Le due funzioni vengono utilizzate rispettivamente per aggiungere un vincolo e
un generatore al poliedro. Per quanto riguarda la prima, non è altro che la
\emph{conditional} vista nell'Algoritmo \ref{conditional}, la seconda è un caso a
parte.

Per ogni generatore che viene passato come parametro possono esserci tre casi:

\begin{itemize}
\item \textbf{Il poliedro è vuoto}: in questo caso si controlla che il generatore sia un
punto, successivamente tutto il poliedro viene settato come \emph{universo} e, per
ogni fattore, viene aggiunto un vincolo \(d \cdot 0 = coeff(Var(i))\)
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
if (is_empty()) {
  assert(g.is_point());
  *this = F_Poly(dim, Spec_Elem::UNIVERSE, topology());
  for (dim_type i = dim; i-- > 0; )
    factors[i].add_con(g.divisor() * Var(0) == g.coeff(Var(i)));
  assert(check_inv());
  return;
}
\end{lstlisting}
\item \textbf{Il poliedro non è vuoto e il generatore è un punto}: in questo caso non si fa
altro che costruire un insieme di fattori, ognuno dei quali conterrà il
generatore passato come parametro; infine questi fattori vengono aggiunti al
poliedro tramite la \emph{join}:
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
if (g.is_point()) {
  Factors fs_g;
  const auto nb = num_rows(blocks);
  fs_g.reserve(nb);
  for (dim_type i = 0; i != nb; ++i) {
    const auto& bi = blocks[i];
    const auto nbi = num_rows(bi);
    fs_g.emplace_back(nbi, Spec_Elem::UNIVERSE, topology());
    auto& fi = fs_g.back();
    for (dim_type j = 0; j != nbi; ++j)
      fi.add_con(g.divisor() * Var(j) == g.coeff(Var(bi[j])));
  }
  join(fs_g, blocks);
  assert(check_inv());
  return;
}
\end{lstlisting}
\item \textbf{Il poliedro non è vuoto e il generatore non è un punto}: in questo caso viene
creato un blocco \(\mathcal{B}\) contentente tutte le dimensioni che appaiono
nel generatore, successivamente si crea un blocco \(\overline{\pi} =
  \pi_{\mathcal{P}} \uparrow \mathcal{B}\) tramite il quale si ri-fattorizza il
nostro poliedro in \(\mathcal{P}'\). Infine, per ogni blocco che compare anche
nel generatore si richiama la \texttt{add\_gen()} della PPLite
\lstset{style=mystyle,language=C++,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
  assert(!is_empty() && !g.is_point());
  Block b_g = detail::extract_block(g);
  Blocks b_out = merge(blocks, b_g);
  factors = refactor(factors, blocks, b_out);
  blocks = b_out;

  for (dim_type i = 0; i != num_rows(blocks); ++i) {
    if (detail::are_disjoint(b_g, blocks[i]))
      continue;
    auto g_int = detail::convert(g, blocks[i]);
    factors[i].add_gen(std::move(g_int));
    break;
  }
  assert(check_inv());
\end{lstlisting}
\end{itemize}

\chapter{Conclusione}
\label{sec:orgd0efd2a}

\bibliographystyle{plain}
\renewcommand\bibname{Bibliografia}
\bibliography{mybib}
\end{document}
